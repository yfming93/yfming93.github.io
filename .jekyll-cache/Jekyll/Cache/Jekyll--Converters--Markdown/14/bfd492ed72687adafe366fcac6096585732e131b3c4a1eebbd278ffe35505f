I"óg<ul id="markdown-toc">
  <li><a href="#oclintç®€ä»‹" id="markdown-toc-oclintç®€ä»‹">OCLintç®€ä»‹</a></li>
  <li><a href="#oclintè§„åˆ™-basic-éƒ¨åˆ†" id="markdown-toc-oclintè§„åˆ™-basic-éƒ¨åˆ†">OCLintè§„åˆ™ Basic éƒ¨åˆ†</a></li>
  <li><a href="#oclintè§„åˆ™-unuseed-éƒ¨åˆ†" id="markdown-toc-oclintè§„åˆ™-unuseed-éƒ¨åˆ†">OCLintè§„åˆ™ Unuseed éƒ¨åˆ†</a></li>
  <li><a href="#oclintè§„åˆ™-size-éƒ¨åˆ†" id="markdown-toc-oclintè§„åˆ™-size-éƒ¨åˆ†">OCLintè§„åˆ™ Size éƒ¨åˆ†</a></li>
  <li><a href="#oclintè§„åˆ™-redundant-éƒ¨åˆ†" id="markdown-toc-oclintè§„åˆ™-redundant-éƒ¨åˆ†">OCLintè§„åˆ™ Redundant éƒ¨åˆ†</a></li>
  <li><a href="#oclintè§„åˆ™-naming-éƒ¨åˆ†" id="markdown-toc-oclintè§„åˆ™-naming-éƒ¨åˆ†">OCLintè§„åˆ™ Naming éƒ¨åˆ†</a></li>
  <li><a href="#oclintè§„åˆ™-migration-éƒ¨åˆ†" id="markdown-toc-oclintè§„åˆ™-migration-éƒ¨åˆ†">OCLintè§„åˆ™ Migration éƒ¨åˆ†</a></li>
  <li><a href="#oclintè§„åˆ™-empty-éƒ¨åˆ†" id="markdown-toc-oclintè§„åˆ™-empty-éƒ¨åˆ†">OCLintè§„åˆ™ Empty éƒ¨åˆ†</a></li>
  <li><a href="#oclintè§„åˆ™-design-éƒ¨åˆ†" id="markdown-toc-oclintè§„åˆ™-design-éƒ¨åˆ†">OCLintè§„åˆ™ Design éƒ¨åˆ†</a></li>
  <li><a href="#oclintè§„åˆ™-convention-éƒ¨åˆ†" id="markdown-toc-oclintè§„åˆ™-convention-éƒ¨åˆ†">OCLintè§„åˆ™ Convention éƒ¨åˆ†</a></li>
  <li><a href="#oclintè§„åˆ™-cocoa-éƒ¨åˆ†" id="markdown-toc-oclintè§„åˆ™-cocoa-éƒ¨åˆ†">OCLintè§„åˆ™ CoCoa éƒ¨åˆ†</a></li>
</ul>
<hr />

<h1 id="oclintç®€ä»‹">OCLintç®€ä»‹</h1>
<h4 id="oclintç®€ä»‹">OCLintç®€ä»‹</h4>

<blockquote>
  <p>OCLint is a static code analysis tool for improving quality and reducing defects by inspecting C, C++ and Objective-C code and looking for potential problems like possible bugs, unused code, complicated code, redundant code, code smells, bad practices, and so on.</p>
</blockquote>

<p>å®‰è£…</p>

<blockquote>
  <p>$ brew tap oclint/formulae</p>
  
  <p>$ brew install oclint</p>
</blockquote>

<h3 id="using-oclint-with-xcodebuild">Using OCLint with xcodebuild</h3>

<p><code>xcodebuild -target DemoProject -configuration Debug -scheme DemoProject</code></p>

<h4 id="using-oclint-with-xctool">Using OCLint with xctool</h4>

<p>å®‰è£…</p>

<blockquote>
  <p>$ brew install xctool â€“HEAD</p>
</blockquote>

<p><code>xctool -reporter json-compilation-database:compile_commands.json build</code></p>

<h3 id="using-oclint-with-xcpretty">Using OCLint with xcpretty</h3>

<p>å®‰è£…</p>

<blockquote>
  <p>$ brew install xcpretty</p>
</blockquote>

<p><code>xcodebuild [flags] | xcpretty -r json-compilation-database -o compile_commands.json</code></p>

<h3 id="using-oclint-in-xcode">Using OCLint in Xcode</h3>

<ul>
<li><p>Add a new target in the project, and choose Aggregate as the template. <br />
</p><center> <br />
 <img src="http://osz3uubsl.bkt.clouddn.com/blog_8_2_git_undo_01.png" width="500" alt="å›¾ç‰‡åç§°" align="center" /> <br />
</center><p></p></li>
<li><p>Name the new target, here we simply call it â€œOCLintâ€, you could have more than one targets that focus on different aspects of the code analysis.</p></li>
</ul>

<p></p>
<center> <br />
     <img src="http://osz3uubsl.bkt.clouddn.com/blog_8_2_git_undo_02.png" width="500" alt="å›¾ç‰‡åç§°" align="center" /> <br />
</center>
<p></p>

<ul>
<li>Add a new build phase in the target we just created. Choose Add Run Script for the phase type.</li>
</ul>

<p></p>
<center> <br />
     <img src="http://osz3uubsl.bkt.clouddn.com/blog_8_2_git_undo_03.png" width="500" alt="å›¾ç‰‡åç§°" align="center" /> <br />
</center>
<p></p>

<ul>
<li>Choose the correct build scheme, here we choose OCLint.Click to build, or use the shortcut Command+B.</li>
<li>Click to build, or use the shortcut Command+B.</li>
<li>When the progress bar scrolls to the very right, the analysis is done, then we can check out the analysis results same as compile warnings. </li>
</ul>

<p></p>
<center> <br />
     <img src="http://osz3uubsl.bkt.clouddn.com/blog_8_2_git_undo_04.png" width="500" alt="å›¾ç‰‡åç§°" align="center" /> <br />
</center>
<p></p>

<p><br /></p>

<h1 id="oclintè§„åˆ™-basic-éƒ¨åˆ†">OCLintè§„åˆ™ Basic éƒ¨åˆ†</h1>

<h4 id="1bitwise-operator-in-conditional">1ã€bitwise operator in conditional</h4>

<p>&nbsp; &nbsp; &nbsp;  <code>since:0.6</code>  <a href="https://github.com/oclint/oclint/blob/master/oclint-rules/rules/basic/BitwiseOperatorInConditionalRule.cpp" rel="nofollow" target="_blank">å®šä¹‰ç±»ä¼ é€é—¨ï½ç‚¹å‡»</a></p>

<blockquote>
  <p>Checks for bitwise operations in conditionals. Although being written on purpose in some rare cases, bitwise opera- tions are considered to be too â€œsmartâ€. Smart code is not easy to understand.</p>
  
  <p>ç®€å•è§£é‡Šï¼šOCLintè®¤ä¸º<code>ä½è¿ç®—ç¬¦</code>å¯è¯»æ€§ä¸å¥½</p>
</blockquote>

<pre class="highlight"><code class=" hljs cs"><span class="hljs-keyword"> void</span> example(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b) {
        <span class="hljs-keyword">if</span> (a | b) {
        }
        <span class="hljs-keyword">if</span> (a &amp; b) {
        }
     }</code></pre>

<h4 id="2broken-null-check">2ã€broken null check</h4>

<p>&nbsp; &nbsp; &nbsp;  <code>since:0.7</code>   <a href="https://github.com/oclint/oclint/blob/master/oclint-rules/rules/basic/BrokenNullCheckRule.cpp" rel="nofollow" target="_blank">å®šä¹‰ç±»ä¼ é€é—¨ï½ç‚¹å‡»</a></p>

<blockquote>
  <p>The broken null check itself will crash the program.</p>
  
  <p>ç®€å•è§£é‡Šï¼šé”™è¯¯çš„nullæ£€æŸ¥ä¼šå¯¼è‡´ç¨‹åº<code>crash</code>ã€‚</p>
</blockquote>

<pre class="highlight"><code class=" hljs livecodeserver">    void m(A *<span class="hljs-operator">a</span>, B *b) {
        <span class="hljs-keyword">if</span> (<span class="hljs-operator">a</span> != <span class="hljs-constant">NULL</span> || <span class="hljs-operator">a</span>-&gt;bar(b))
        {
        }
        <span class="hljs-keyword">if</span> (<span class="hljs-operator">a</span> == <span class="hljs-constant">NULL</span> &amp;&amp; <span class="hljs-operator">a</span>-&gt;bar(b))
        {
        }
    }   </code></pre>

<blockquote>
  <p><font color="red">PSï¼š</font>OC(objective-c)å‘ç©ºå¯¹è±¡å¯ä»¥å‘æ¶ˆæ¯ï¼Œä¸ä¼šå‘ç”Ÿ<code>crash</code>ï¼Œä½†æ˜¯ä¸Šé¢è¿™æ ·çš„ä»£ç çš„é€»è¾‘æ˜¯é”™è¯¯çš„ã€‚</p>
</blockquote>

<h4 id="3broken-nil-check">3ã€broken nil check</h4>

<p>&nbsp; &nbsp; &nbsp;  <code>since:0.7</code> <a href="https://github.com/oclint/oclint/blob/master/oclint-rules/rules/basic/BrokenNullCheckRule.cpp" rel="nofollow" target="_blank">å®šä¹‰ç±»ä¼ é€é—¨ï½ç‚¹å‡»</a></p>

<blockquote>
  <p>The broken nil check in Objective-C in some cases returns just the opposite result.</p>
  
  <p>ç®€å•è§£é‡Šï¼šObjective-Cä¸­åˆ¤ç©ºï¼Œæœ‰äº›æƒ…å†µä¸‹ä¼šè¿”å›é¢„æœŸç›¸åçš„ç»“æœ</p>
</blockquote>

<pre class="highlight"><code class="language-Objective-C hljs cs">    + (<span class="hljs-keyword">void</span>)compare:(A *)obj1 withOther:(A *)obj2 {
        <span class="hljs-keyword">if</span> (obj1 || [obj1 isEqualTo:obj2])
        {
        }
        <span class="hljs-keyword">if</span> (!obj1 &amp;&amp; ![obj1 isEqualTo:obj2])
        {
        }
    }</code></pre>

<blockquote>
  <p><font color="red">PSï¼š</font>è¿™æ ·å†™åº”è¯¥æ˜¯é€»è¾‘é”™è¯¯</p>
</blockquote>

<h4 id="4broken-oddness-check">4ã€broken oddness check</h4>

<p>&nbsp; &nbsp; &nbsp;  <code>since:0.6</code> <a href="https://github.com/oclint/oclint/blob/master/oclint-rules/rules/basic/BrokenOddnessCheckRule.cpp" rel="nofollow" target="_blank">å®šä¹‰ç±»ä¼ é€é—¨ï½ç‚¹å‡»</a></p>

<blockquote>
  <p>Checking oddness by x % 2 == 1wonâ€™t work for negative numbers. Use x &amp; 1 == 1,or x % 2 != 0 instead.</p>
  
  <p>ç®€å•è§£é‡Šï¼šå¯¹æ•°å­—å¥‡æ•°æ€§è¿›è¡Œæ£€æŸ¥ï¼ˆx % 2 == 1ï¼‰ï¼Œå¦‚æœæ˜¯è´Ÿæ•°ï¼Œä¼šæœ‰å¼‚å¸¸ï¼Œåº”ä½¿ç”¨<code>x &amp; 1 == 1</code>æˆ–è€…<code>x % 2 != 0</code></p>
</blockquote>

<pre class="highlight"><code class=" hljs cs">    <span class="hljs-keyword">void</span> example() {
        <span class="hljs-keyword">if</span> (x % <span class="hljs-number">2</span> == <span class="hljs-number">1</span>)         <span class="hljs-comment">// violation</span>
        {
        }
        <span class="hljs-keyword">if</span> (foo() % <span class="hljs-number">2</span> == <span class="hljs-number">1</span>)     <span class="hljs-comment">// violation</span>
        {
        }
    }</code></pre>

<blockquote>
  <p><font color="red">PSï¼š</font>åœ¨Objective-C ä¸Šçš„æµ‹è¯•ç»“æœä¸Šçœ‹ï¼Œå¹¶æ²¡æœ‰ä»€ä¹ˆå¤§çš„å¼‚å¸¸ã€‚åº”è¯¥ä¸»è¦çš„é—®é¢˜æ˜¯è´Ÿæ•°è¿›è¡Œå–æ¨¡åŒºçš„ç»“æœä¸ä¼šå‡ºç°æ­£å€¼ã€‚ <br />
  æ¯”å¦‚ï¼ˆx % 2ï¼‰çš„ç»“æœæ˜¯<code>-1</code>æˆ–è€…<code>0</code>ï¼Œ</p>
</blockquote>

<h4 id="5collapsible-if-statements">5ã€collapsible if statements</h4>

<p>&nbsp; &nbsp; &nbsp;  <code>Since: 0.6</code>  <a href="https://github.com/oclint/oclint/blob/master/oclint-rules/rules/basic/CollapsibleIfStatementsRule.cpp" rel="nofollow" target="_blank">å®šä¹‰ç±»ä¼ é€é—¨ï½ç‚¹å‡»</a></p>

<blockquote>
  <p>This rule detects instances where the conditions of two consecutive if statements can be combined into one in order to increase code cleanness and readability.</p>
  
  <p>ç®€å•è§£é‡Šï¼šä¸¤ä¸ªè¿ç»­<code>if</code>æ¡ä»¶å¯ä»¥åˆå¹¶çš„åº”è¯¥åˆå¹¶ï¼Œå¯ä»¥æé«˜å¯è¯»æ€§å’Œä»£ç æ•´æ´ã€‚</p>
</blockquote>

<pre class="highlight"><code class=" hljs cs">    <span class="hljs-keyword">void</span> example(<span class="hljs-keyword">bool</span> x, <span class="hljs-keyword">bool</span> y){
        <span class="hljs-keyword">if</span> (x)              <span class="hljs-comment">// these two if statements can be</span>
        {
            <span class="hljs-keyword">if</span> (y)          <span class="hljs-comment">// combined to if (x &amp;&amp; y)</span>
            {
                foo();
            }
        }
    }</code></pre>

<h4 id="6constant-conditional-operator">6ã€constant conditional operator</h4>

<p>&nbsp; &nbsp; &nbsp;  <code>Since: 0.6</code>  <a href="https://github.com/oclint/oclint/blob/master/oclint-rules/rules/basic/ConstantConditionalOperatorRule.cpp" rel="nofollow" target="_blank">å®šä¹‰ç±»ä¼ é€é—¨ï½ç‚¹å‡»</a></p>

<blockquote>
  <p>conditional operator whose conditionals are always true or always false are confusing.</p>
  
  <p>ç®€å•è§£é‡Šï¼šæ£€æŸ¥å§‹ç»ˆä¸º<code>true</code>æˆ–è€…<code>false</code>çš„æ“ä½œï¼Œä¼šä½¿äººç–‘æƒ‘ã€‚</p>
</blockquote>

<pre class="highlight"><code class=" hljs cs">    <span class="hljs-keyword">void</span> example() {
        <span class="hljs-keyword">int</span> a = <span class="hljs-number">1</span> == <span class="hljs-number">1</span> ? <span class="hljs-number">1</span> : <span class="hljs-number">0</span>;     <span class="hljs-comment">// 1 == 1 is actually always true</span>
    }</code></pre>

<h4 id="7constant-if-expression">7ã€constant if expression</h4>

<p>&nbsp; &nbsp; &nbsp;  <code>Since: 0.2</code> <a href="https://github.com/oclint/oclint/blob/master/oclint-rules/rules/basic/ConstantIfExpressionRule.cpp" rel="nofollow" target="_blank">å®šä¹‰ç±»ä¼ é€é—¨ï½ç‚¹å‡»</a></p>

<blockquote>
  <p>if statements whose conditionals are always true or always false are confusing.</p>
  
  <p>ç®€å•è§£é‡Šï¼š<code>if</code>å§‹ç»ˆä¸º<code>true</code>æˆ–è€…<code>false</code>çš„æ“ä½œï¼Œä¼šä½¿äººç–‘æƒ‘ã€‚</p>
</blockquote>

<pre class="highlight"><code class=" hljs ruby">    void example(){
        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">true</span>) {      <span class="hljs-regexp">//</span> always <span class="hljs-keyword">true</span>
            foo();
        }
        <span class="hljs-keyword">if</span> (<span class="hljs-number">1</span> == <span class="hljs-number">0</span>) {    <span class="hljs-regexp">//</span> always <span class="hljs-keyword">false</span>
            bar();
        }
    }</code></pre>

<h4 id="8-dead-code">8ã€ dead code</h4>

<p>&nbsp; &nbsp; &nbsp;  <code>Since: 0.4</code> <a href="https://github.com/oclint/oclint/blob/master/oclint-rules/rules/basic/DeadCodeRule.cpp" rel="nofollow" target="_blank">å®šä¹‰ç±»ä¼ é€é—¨ï½ç‚¹å‡»</a></p>

<blockquote>
  <p>Code after return, break, continue, and throw statements is unreachable and will never be executed.</p>
  
  <p>ç®€å•è§£é‡Šï¼šåœ¨ <code>return</code>ã€ <code>break</code>ã€ <code>continue</code> and <code>throw</code> ä¹‹åçš„ä»£ç éƒ½æ˜¯æ— æ•ˆçš„</p>
</blockquote>

<pre class="highlight"><code class=" hljs objectivec">    <span class="hljs-keyword">void</span> example(<span class="hljs-keyword">id</span> collection) {
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">id</span> it in collection) {
            <span class="hljs-keyword">continue</span>;
            <span class="hljs-keyword">int</span> i1;                 <span class="hljs-comment">// dead code</span>
        }
        <span class="hljs-keyword">return</span>;
        <span class="hljs-keyword">int</span> i2;                     <span class="hljs-comment">// dead code</span>
    }</code></pre>

<h4 id="9double-negative">9ã€double negative</h4>

<p>&nbsp; &nbsp; &nbsp;  <code>Since:0.6</code> <a href="https://github.com/oclint/oclint/blob/master/oclint-rules/rules/basic/DoubleNegativeRule.cpp" rel="nofollow" target="_blank">å®šä¹‰ç±»ä¼ é€é—¨ï½ç‚¹å‡»</a></p>

<blockquote>
  <p>There is no point in using a double negative, it is always positive.</p>
  
  <p>ç®€å•è§£é‡Šï¼šä»£ç ä¸­åŒé‡å¦å®šæ²¡æœ‰æ„ä¹‰</p>
</blockquote>

<pre class="highlight"><code class=" hljs cs">    <span class="hljs-keyword">void</span> example() {
        <span class="hljs-keyword">int</span> b1 = !!<span class="hljs-number">1</span>;
        <span class="hljs-keyword">int</span> b2 = ~~<span class="hljs-number">1</span>;
    }</code></pre>

<h4 id="10for-loop-should-be-while-loop">10ã€for loop should be while loop</h4>

<p>&nbsp; &nbsp; &nbsp;  <code>Since:0.6</code> <a href="https://github.com/oclint/oclint/blob/master/oclint-rules/rules/basic/ForLoopShouldBeWhileLoopRule.cpp" rel="nofollow" target="_blank">å®šä¹‰ç±»ä¼ é€é—¨ï½ç‚¹å‡»</a></p>

<blockquote>
  <p>Under certain circumstances, some for loops can be simplified to while loops to make code more concise.</p>
  
  <p>ç®€å•è§£é‡Šï¼šåœ¨æœ‰äº›æƒ…å†µä¸‹ä½¿ç”¨<code>while</code>æ¯”ä½¿ç”¨<code>for</code>æ›´ç®€æ´</p>
</blockquote>

<pre class="highlight"><code class=" hljs cs">    <span class="hljs-keyword">void</span> example(<span class="hljs-keyword">int</span> a) {
        <span class="hljs-keyword">for</span> (; a &lt; <span class="hljs-number">100</span>;) {
            foo(a);
        }
    }</code></pre>

<h4 id="11-goto-statement">11ã€ goto statement</h4>

<p>&nbsp; &nbsp; &nbsp;  <code>Since:0.6</code> <a href="https://github.com/oclint/oclint/blob/master/oclint-rules/rules/basic/GotoStatementRule.cpp" rel="nofollow" target="_blank">å®šä¹‰ç±»ä¼ é€é—¨ï½ç‚¹å‡»</a></p>

<blockquote>
  <p><a href="http://www.cs.utexas.edu/users/EWD/ewd02xx/EWD215.PDF" rel="nofollow" target="_blank">Go To Statement Considered Harmful</a></p>
  
  <p>ç®€å•è§£é‡Šï¼š<a href="http://www.cs.utexas.edu/users/EWD/ewd02xx/EWD215.PDF" rel="nofollow" target="_blank"><code>go to</code>è¢«è®¤ä¸ºæœ‰å®³çš„ </a></p>
</blockquote>

<pre class="highlight"><code class=" hljs cs">    <span class="hljs-keyword">void</span> example() {
        A:
            a();
        <span class="hljs-keyword">goto</span> A;     <span class="hljs-comment">// Considered Harmful</span>
    }</code></pre>

<h4 id="12jumbled-incrementer">12ã€jumbled incrementer</h4>

<p>&nbsp; &nbsp; &nbsp;  <code>Since:0.7</code> <a href="https://github.com/oclint/oclint/blob/master/oclint-rules/rules/basic/JumbledIncrementerRule.cpp" rel="nofollow" target="_blank">å®šä¹‰ç±»ä¼ é€é—¨ï½ç‚¹å‡»</a></p>

<blockquote>
  <p>Jumbled incrementers are usually typos. If itâ€™s done on purpose, itâ€™s very confusing for code readers.</p>
  
  <p>ç®€å•è§£é‡Šï¼šæ··ä¹±çš„è¿­ä»£å™¨é€šå¸¸ä¼šå‡ºç°é”™è¯¯ï¼Œå¯è¯»æ€§ä¸å¥½ã€‚</p>
</blockquote>

<pre class="highlight"><code class=" hljs perl">    void aMethod(<span class="hljs-keyword">int</span> a) {
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; a; i++) {
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; a; i++) {     <span class="hljs-regexp">//</span> references both <span class="hljs-string">'i'</span> <span class="hljs-keyword">and</span> <span class="hljs-string">'j'</span>
            }
        }
    }</code></pre>

<h4 id="13misplaced-null-check">13ã€misplaced null check</h4>

<p>&nbsp; &nbsp; &nbsp;  <code>Since:0.7</code> <a href="https://github.com/oclint/oclint/blob/master/oclint-rules/rules/basic/MisplacedNullCheckRule.cpp" rel="nofollow" target="_blank">å®šä¹‰ç±»ä¼ é€é—¨ï½ç‚¹å‡»</a></p>

<blockquote>
  <p>The null check is misplaced. In C and C++, sending a message to a null pointer could crash the program. When null is misplaced, either the check is useless or itâ€™s incorrect.</p>
  
  <p>ç®€å•è§£é‡Šï¼š<code>C</code>å’Œ<code>C++</code>åœ¨æ¡ä»¶åˆ¤æ–­çš„æ—¶å€™æ³¨æ„<code>null</code>åˆ¤æ–­æ”¾åœ¨å‰é¢ï¼Œ<code>é€»è¾‘çŸ­è·¯</code>ã€‚</p>
</blockquote>

<pre class="highlight"><code class=" hljs livecodeserver">    void m(A *<span class="hljs-operator">a</span>, B *b) {
        <span class="hljs-keyword">if</span> (<span class="hljs-operator">a</span>-&gt;bar(b) &amp;&amp; <span class="hljs-operator">a</span> != <span class="hljs-constant">NULL</span>) {<span class="hljs-comment"> // violation </span>
        }
        <span class="hljs-keyword">if</span> (<span class="hljs-operator">a</span>-&gt;bar(b) || !<span class="hljs-operator">a</span>) {       <span class="hljs-comment"> // violation</span>
        }
    }</code></pre>

<h4 id="14misplaced-nil-check">14ã€misplaced nil check</h4>

<p>&nbsp; &nbsp; &nbsp;  <code>Since:0.7</code> <a href="https://github.com/oclint/oclint/blob/master/oclint-rules/rules/basic/MisplacedNullCheckRule.cpp" rel="nofollow" target="_blank">å®šä¹‰ç±»ä¼ é€é—¨ï½ç‚¹å‡»</a></p>

<blockquote>
  <p>The nil check is misplaced. In Objective-C, sending a message to a nil pointer simply does nothing. But code readers may be confused about the misplaced nil check.</p>
  
  <p>ç®€å•è§£é‡Šï¼š<code>Objective-C</code>åœ¨æ¡ä»¶åˆ¤æ–­çš„æ—¶å€™æ³¨æ„<code>nil</code>åˆ¤æ–­æ”¾åœ¨å‰é¢ï¼Œ<code>é€»è¾‘çŸ­è·¯</code>ã€‚</p>
</blockquote>

<pre class="highlight"><code class=" hljs objectivec">    + (<span class="hljs-keyword">void</span>)compare:(A *)obj1 withOther:(A *)obj2 {
        <span class="hljs-keyword">if</span> ([obj1 isEqualTo:obj2] &amp;&amp; obj1) {
        }
        <span class="hljs-keyword">if</span> (![obj1 isEqualTo:obj2] || obj1 == <span class="hljs-literal">nil</span>)   {
        }
    }</code></pre>

<h4 id="15-multiple-unary-operator">15ã€ multiple unary operator</h4>

<p>&nbsp; &nbsp; &nbsp;  <code>Since:0.6</code> <a href="https://github.com/oclint/oclint/blob/master/oclint-rules/rules/basic/MultipleUnaryOperatorRule.cpp" rel="nofollow" target="_blank">å®šä¹‰ç±»ä¼ é€é—¨ï½ç‚¹å‡»</a></p>

<blockquote>
  <p>Multiple unary operator can always be confusing and should be simplified.</p>
  
  <p>ç®€å•è§£é‡Šï¼šå¤šé‡çš„è¿ç®—ç¬¦ä¸æ˜“ç†è§£ï¼Œåº”è¯¥ç®€åŒ–ã€‚</p>
</blockquote>

<pre class="highlight"><code class=" hljs cs">    <span class="hljs-keyword">void</span> example() {
        <span class="hljs-keyword">int</span> b = -(+(!(~<span class="hljs-number">1</span>)));
    }</code></pre>

<h4 id="16return-from-finally-block">16ã€return from finally block</h4>

<p>&nbsp; &nbsp; &nbsp;  <code>Since:0.6</code> <a href="https://github.com/oclint/oclint/blob/master/oclint-rules/rules/basic/ReturnFromFinallyBlockRule.cpp" rel="nofollow" target="_blank">å®šä¹‰ç±»ä¼ é€é—¨ï½ç‚¹å‡»</a></p>

<blockquote>
  <p>Returning from a finally block is not recommended.</p>
  
  <p>ç®€å•è§£é‡Šï¼šä¸å»ºè®®åœ¨finallyä¸­è¿”å›</p>
</blockquote>

<pre class="highlight"><code class=" hljs scss">    void <span class="hljs-function">example()</span> {
        <span class="hljs-at_rule">@try {</span>
            <span class="hljs-function">foo()</span>;
        }
        <span class="hljs-at_rule">@<span class="hljs-function">catch(id ex)</span> {</span>
            <span class="hljs-function">bar()</span>;
        }
        <span class="hljs-at_rule">@finally {</span>
            return;         <span class="hljs-comment">// this can discard exceptions.</span>
        }
    }</code></pre>

<h4 id="17throw-exception-from-finally-block">17ã€throw exception from finally block</h4>

<p>&nbsp; &nbsp; &nbsp;  <code>Since:0.6</code> <a href="--" rel="nofollow" target="_blank">å®šä¹‰ç±»ä¼ é€é—¨ï½ç‚¹å‡»</a></p>

<blockquote>
  <p>Throwing exceptions within a finally block may mask other exceptions or code defects.</p>
  
  <p>ç®€å•è§£é‡Šï¼šä»finallyå—æŠ›å‡ºå¼‚å¸¸ï¼Œå¯èƒ½å¿½ç•¥å…¶ä»–çš„é”™è¯¯</p>
</blockquote>

<pre class="highlight"><code class=" hljs objectivec">    <span class="hljs-keyword">void</span> example() {
        <span class="hljs-keyword">@try</span> {;}
        <span class="hljs-keyword">@catch</span>(<span class="hljs-keyword">id</span> ex) {;}
        <span class="hljs-keyword">@finally</span> {
            <span class="hljs-keyword">id</span> ex1;
            <span class="hljs-keyword">@throw</span> ex1;                              <span class="hljs-comment">// this throws an exception</span>
            <span class="hljs-built_in">NSException</span> *ex2 = [<span class="hljs-built_in">NSException</span> new];
            [ex2 raise];                             <span class="hljs-comment">// this throws an exception, too</span>
        }
    }</code></pre>

<h1 id="oclintè§„åˆ™-unuseed-éƒ¨åˆ†">OCLintè§„åˆ™ Unuseed éƒ¨åˆ†</h1>

<h4 id="1unused-local-variable">1ã€unused local variable</h4>

<p>&nbsp; &nbsp; &nbsp;  <code>Since:0.4</code> <a href="https://github.com/oclint/oclint/blob/master/oclint-rules/rules/unused/UnusedLocalVariableRule.cpp" rel="nofollow" target="_blank">å®šä¹‰ç±»ä¼ é€é—¨ï½ç‚¹å‡»</a></p>

<blockquote>
  <p>This rule detects local variables that are declared, but not used.</p>
  
  <p>ç®€å•è§£é‡Šï¼šæœ‰å±€éƒ¨å˜é‡æ²¡æœ‰ä½¿ç”¨ã€‚</p>
</blockquote>

<pre class="highlight"><code class=" hljs cs">    <span class="hljs-keyword">int</span> example(<span class="hljs-keyword">int</span> a) {
        <span class="hljs-keyword">int</span> i;          <span class="hljs-comment">// variable i is declared, but not used</span>
        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
    }</code></pre>

<blockquote>
  <p>Suppress: <br />
  <code>__attribute__((annotate("oclint:suppress[unused local variable]")))</code></p>
</blockquote>

<h4 id="2unused-method-parameter">2ã€unused method parameter</h4>

<p>&nbsp; &nbsp; &nbsp;  <code>Since:0.4</code> <a href="https://github.com/oclint/oclint/blob/master/oclint-rules/rules/unused/UnusedMethodParameterRule.cpp" rel="nofollow" target="_blank">å®šä¹‰ç±»ä¼ é€é—¨ï½ç‚¹å‡»</a></p>

<blockquote>
  <p>This rule detects parameters that are not used in the method.</p>
  
  <p>ç®€å•è§£é‡Šï¼šæ–¹æ³•å‚æ•°æ²¡æœ‰è¢«ä½¿ç”¨.</p>
</blockquote>

<pre class="highlight"><code class=" hljs cs">    <span class="hljs-keyword">int</span> example(<span class="hljs-keyword">int</span> a)  <span class="hljs-comment">// parameter a is not used {</span>
        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
    }</code></pre>

<blockquote>
  <p>Suppress: <br />
  <code>__attribute__((annotate("oclint:suppress[unused method parameter]")))</code></p>
</blockquote>

<h1 id="oclintè§„åˆ™-size-éƒ¨åˆ†">OCLintè§„åˆ™ Size éƒ¨åˆ†</h1>

<h4 id="1high-cyclomatic-complexity">1ã€high cyclomatic complexity</h4>

<p>&nbsp; &nbsp; &nbsp;  <code>Since:0.4</code> <a href="https://github.com/oclint/oclint/blob/master/oclint-rules/rules/size/CyclomaticComplexityRule.cpp" rel="nofollow">å®šä¹‰ç±»ä¼ é€é—¨ï½ç‚¹å‡»</a></p>

<blockquote>
  <p>Cyclomatic complexity is determined by the number of linearly independent paths through a programâ€™s source code. In other words, cyclomatic complexity of a method is measured by the number of decision points, like if, while, and for statements, plus one for the method entry.</p>
  
  <p>ç®€å•è§£é‡Šï¼šåœˆå¤æ‚åº¦è¿‡é«˜ã€‚ç»Ÿè®¡ä¸€ä¸ªå‡½æ•°æœ‰å¤šå°‘ä¸ªåˆ†æ”¯(if, while,for,ç­‰ç­‰)ï¼Œæ²¡æœ‰çš„è¯å¤æ‚åº¦ä¸ºä¸€ï¼Œæ¯å¢åŠ ä¸€ä¸ªåˆ†æ”¯å¤æ‚åº¦åŠ ä¸€ã€‚ç®€å•è®¡ç®—çš„è¯V(G)=e-n+2ã€‚å…¶ä¸­ï¼Œeè¡¨ç¤ºæ§åˆ¶æµå›¾ä¸­è¾¹çš„æ•°é‡ï¼Œnè¡¨ç¤ºæ§åˆ¶æµå›¾ä¸­èŠ‚ç‚¹çš„æ•°é‡ï¼Œæˆ–è€…V(G)=åŒºåŸŸæ•°=åˆ¤å®šèŠ‚ç‚¹æ•°+1ã€‚å½“ç„¶å¯ä»¥æ•°ä¸€æ•°ã€‚</p>
</blockquote>

<pre class="highlight"><code class=" hljs cs">    <span class="hljs-keyword">void</span> example(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b, <span class="hljs-keyword">int</span> c) { <span class="hljs-comment">// 1</span>
        <span class="hljs-keyword">if</span> (a == b) {                   <span class="hljs-comment">// 2</span>
            <span class="hljs-keyword">if</span> (b == c) {               <span class="hljs-comment">// 3 </span>
            } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (a == c){          <span class="hljs-comment">// 3</span>
            }
            <span class="hljs-keyword">else</span> {
            }
        }
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; c; i++)  {  <span class="hljs-comment">// 4</span>
        }
        <span class="hljs-keyword">switch</span>(c)  {
            <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:                   <span class="hljs-comment">// 5</span>
                <span class="hljs-keyword">break</span>;
            <span class="hljs-keyword">case</span> <span class="hljs-number">2</span>:                   <span class="hljs-comment">// 6</span>
                <span class="hljs-keyword">break</span>;
            <span class="hljs-keyword">default</span>:                  <span class="hljs-comment">// 7</span>
                <span class="hljs-keyword">break</span>;
        }
    }</code></pre>

<blockquote>
  <p>Thresholds: <br />
  CYCLOMATIC_COMPLEXITY The cyclomatic complexity reporting threshold, default value is 10. Suppress:</p>
  
  <p>Suppress: <br />
  <code>__attribute__((annotate("oclint:suppress[high cyclomatic complexity]")))</code></p>
  
  <p>References: <br />
  McCabe (December 1976). <a href="http://www.literateprogramming.com/mccabe.pdf" rel="nofollow">â€œA Complexity Measureâ€</a>. IEEE Transactions on Software Engineering: 308â€“320</p>
</blockquote>

<h4 id="2long-class">2ã€long class</h4>

<p>&nbsp; &nbsp; &nbsp;  <code>Since:0.6</code> <a href="https://github.com/oclint/oclint/blob/master/oclint-rules/rules/size/LongClassRule.cpp" rel="nofollow">å®šä¹‰ç±»ä¼ é€é—¨ï½ç‚¹å‡»</a></p>

<blockquote>
  <p>Long class generally indicates that this class tries to do many things. Each class should do one thing and that one thing well.</p>
  
  <p>ç®€å•è§£é‡Šï¼šç±»è¡Œæ•°å¤ªå¤šã€‚</p>
</blockquote>

<pre class="highlight"><code class=" hljs actionscript">    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Foo</span> {</span>
        <span class="hljs-keyword">void</span> bar() {
            <span class="hljs-comment">// 1001 lines of code</span>
        }
    }</code></pre>

<blockquote>
  <p>Thresholds: <br />
  LONG_CLASS The class size reporting threshold, default value is 1000.</p>
</blockquote>

<h4 id="3-long-line">3ã€ long line</h4>

<p>&nbsp; &nbsp; &nbsp;  <code>Since:0.6</code> <a href="https://github.com/oclint/oclint/blob/master/oclint-rules/rules/size/LongLineRule.cpp" rel="nofollow">å®šä¹‰ç±»ä¼ é€é—¨ï½ç‚¹å‡»</a></p>

<blockquote>
  <p>When the number of characters for one line of code is very high, it largely harms the readability. Break long lines of code into multiple lines.</p>
  
  <p>ç®€å•è§£é‡Šï¼šå•è¡Œä»£ç å¤ªé•¿ï¼Œå½±å“å¯è¯»æ€§ã€‚</p>
</blockquote>

<pre class="highlight"><code class=" hljs cs">    <span class="hljs-keyword">void</span> example()
    {
        <span class="hljs-keyword">int</span> a012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789;
    }</code></pre>

<blockquote>
  <p>Thresholds: <br />
  LONG_LINE The long line reporting threshold, default value is 100.</p>
</blockquote>

<h4 id="4long-method">4ã€long method</h4>

<p>&nbsp; &nbsp; &nbsp;  <code>Since:0.6</code> <a href="https://github.com/oclint/oclint/blob/master/oclint-rules/rules/size/LongMethodRule.cpp" rel="nofollow">å®šä¹‰ç±»ä¼ é€é—¨ï½ç‚¹å‡»</a></p>

<blockquote>
  <p>Long method generally indicates that this method tries to do many things. Each method should do one thing and that one thing well.</p>
  
  <p>ç®€å•è§£é‡Šï¼šæ–¹æ³•å¤ªé•¿ï¼Œå½±å“é˜…è¯»ï¼Œåº”è¯¥å®ç°å•ä¸€èŒè´£ã€‚</p>
</blockquote>

<pre class="highlight"><code class=" hljs cpp">    <span class="hljs-keyword">void</span> example() {
        <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"hello world"</span>;
        <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"hello world"</span>;
        <span class="hljs-comment">// repeat 48 times</span>
    }</code></pre>

<blockquote>
  <p>Thresholds: <br />
  LONG_METHOD The long method reporting threshold, default value is 50.</p>
</blockquote>

<h4 id="5-high-ncss-method">5ã€ high ncss method</h4>

<p>&nbsp; &nbsp; &nbsp;  <code>Since:0.6</code> <a href="https://github.com/oclint/oclint/blob/master/oclint-rules/rules/size/NcssMethodCountRule.cpp" rel="nofollow">å®šä¹‰ç±»ä¼ é€é—¨ï½ç‚¹å‡»</a></p>

<blockquote>
  <p>This rule counts number of lines for a method by counting Non Commenting Source Statements (NCSS). NCSS only takes actual statements into consideration, in other words, ignores empty statements, empty blocks, closing brackets or semicolons after closing brackets. Meanwhile, a statement that is broken into multiple lines contribute only one count.</p>
  
  <p>ç®€å•è§£é‡Šï¼šå…¶å®æ˜¯æŒ‡æŸä¸ªä»£ç å—ä¸­ä»£ç è¡Œæ•°è¿‡å¤šï¼ˆåªç»Ÿè®¡æœ‰æ•ˆçš„è¯­å¥ï¼‰ï¼ŒæŸ¥çœ‹ä»£ç å—ä¸­ä»£ç æ˜¯å¦èƒ½æ‹†åˆ†ï¼Œå…¬å…±åŠŸèƒ½èƒ½å¦æä¾›ä¸€ä¸ªå…¬å…±æ¥å£ã€‚ç©ºè¯­å¥ï¼Œç©ºå—ï¼Œå³æ‹¬å·æˆ–åˆ†å·åçš„å³æ‹¬å·ä¼šè¢«å¿½ç•¥ã€‚</p>
</blockquote>

<pre class="highlight"><code class=" hljs cs">    <span class="hljs-keyword">void</span> example()          <span class="hljs-comment">// 1</span>
    {
        <span class="hljs-keyword">if</span> (<span class="hljs-number">1</span>)              <span class="hljs-comment">// 2</span>
        {
        }  <span class="hljs-keyword">else</span>                <span class="hljs-comment">// 3</span>
        {
        }
    }</code></pre>

<blockquote>
  <p>Thresholds: <br />
  NCSS_METHOD The high NCSS method reporting threshold, default value is 30.</p>
  
  <p>Suppress: <br />
  <strong>attribute</strong>((annotate(â€œoclint:suppress[high ncss method]â€)))</p>
</blockquote>

<h4 id="6deep-nested-block">6ã€deep nested block</h4>

<p>&nbsp; &nbsp; &nbsp;  <code>Since:0.6</code> <a href="https://github.com/oclint/oclint/blob/master/oclint-rules/rules/size/NestedBlockDepthRule.cpp" rel="nofollow">å®šä¹‰ç±»ä¼ é€é—¨ï½ç‚¹å‡»</a></p>

<blockquote>
  <p>This rule indicates blocks nested more deeply than the upper limit.</p>
  
  <p>ç®€å•è§£é‡Šï¼šåµŒå¥—å—æ˜¯å¦è¶…è¿‡æŒ‡å®šçš„æ·±åº¦å€¼.</p>
</blockquote>

<pre class="highlight"><code class=" hljs cs">    <span class="hljs-keyword">if</span> (<span class="hljs-number">1</span>) {               <span class="hljs-comment">// 1</span>
        {           <span class="hljs-comment">// 2</span>
            {       <span class="hljs-comment">// 3</span>
            }
        }
    }</code></pre>

<blockquote>
  <p>Thresholds: <br />
  NESTED_BLOCK_DEPTH The depth of a block or compound statement reporting threshold, default value is 5.</p>
</blockquote>

<h4 id="7high-npath-complexity">7ã€high npath complexity</h4>

<p>&nbsp; &nbsp; &nbsp;  <code>Since:0.4</code> <a href="https://github.com/oclint/oclint/blob/master/oclint-rules/rules/size/NPathComplexityRule.cpp" rel="nofollow">å®šä¹‰ç±»ä¼ é€é—¨ï½ç‚¹å‡»</a></p>

<blockquote>
  <p>NPath complexity is determined by the number of execution paths through that method. Compared to cyclomatic complexity, NPath complexity has two outstanding characteristics: first, it distinguishes between different kinds of control flow structures; second, it takes the various type of acyclic paths in a flow graph into consideration. <br />
  Based on studies done by the original author in AT&amp;T Bell Lab, an NPath threshold value of 200 has been established for a method.</p>
  
  <p>ç®€å•è§£é‡Šï¼šNPathå¤æ‚åº¦æ˜¯ä¸€ä¸ªæ–¹æ³•ä¸­å„ç§å¯èƒ½çš„æ‰§è¡Œè·¯å¾„æ€»å’Œ,ä¸€èˆ¬æŠŠ200ä½œä¸ºè€ƒè™‘é™ä½å¤æ‚åº¦çš„ä¸´ç•Œç‚¹ï¼Œè¿™é‡Œæç¤ºNPathå¤æ‚åº¦è¿‡é«˜ã€‚</p>
</blockquote>

<pre class="highlight"><code class=" hljs cs">    <span class="hljs-keyword">void</span> example() {
        <span class="hljs-comment">// complicated code that is hard to understand</span>
    }</code></pre>

<blockquote>
  <p>Thresholds: <br />
  NPATH_COMPLEXITY The NPath complexity reporting threshold, default value is 200. </p>
  
  <p>Suppress: <br />
  <code>__attribute__((annotate("oclint:suppress[high npath complexity]")))</code></p>
  
  <p>References: <br />
  Brian A. Nejmeh (1988). <a href="http://dl.acm.org/citation.cfm?id=42379" rel="nofollow">â€œNPATH: a measure of execution path complexity and its applicationsâ€</a>. Communications of the ACM 31 (2) p. 188-200</p>
</blockquote>

<h4 id="8too-many-fields">8ã€too many fields</h4>

<p>&nbsp; &nbsp; &nbsp;  <code>Since:0.7</code> <a href="https://github.com/oclint/oclint/blob/master/oclint-rules/rules/size/TooManyFieldsRule.cpp" rel="nofollow">å®šä¹‰ç±»ä¼ é€é—¨ï½ç‚¹å‡»</a></p>

<blockquote>
  <p>A class with too many fields indicates it does too many things and lacks proper abstraction. It can be redesigned to have fewer fields.</p>
  
  <p>ç®€å•è§£é‡Šï¼šä¸€ä¸ªç±»ä¸­æœ‰å®šä¹‰å¤ªå¤šä¸œè¥¿ï¼Œéœ€è¦è¿›è¡Œé€‚å½“çš„æŠ½è±¡ã€è®¾è®¡ã€‚</p>
</blockquote>

<pre class="highlight"><code class=" hljs r">    class c {
        int a, b;
        int c;
        // <span class="hljs-keyword">...</span>
        int l;
        int m, n;
        // <span class="hljs-keyword">...</span>
        int x, y, z;
        void m() {}
    };</code></pre>

<blockquote>
  <p>Thresholds: <br />
  TOO_MANY_FIELDS The reporting threshold for too many fields, default value is 20.</p>
</blockquote>

<h4 id="9too-many-methods">9ã€too many methods</h4>

<p>&nbsp; &nbsp; &nbsp;  <code>Since:0.7</code> <a href="https://github.com/oclint/oclint/blob/master/oclint-rules/rules/size/TooManyMethodsRule.cpp" rel="nofollow">å®šä¹‰ç±»ä¼ é€é—¨ï½ç‚¹å‡»</a></p>

<blockquote>
  <p>A class with too many methods indicates it does too many things and is hard to read and understand. It usually contains complicated code, and should be refactored.</p>
  
  <p>ç®€å•è§£é‡Šï¼šä¸€ä¸ªç±»æœ‰å¤ªå¤šçš„æ–¹æ³•ï¼Œè¯æ˜ä»–åšäº†å¤ªå¤šçš„äº‹å„¿ï¼Œä¸åˆ©äºç†è§£ã€‚åº”è¯¥è€ƒè™‘é‡æ„ã€‚è€ƒè™‘å•ä¸€èŒè´£ã€‚</p>
</blockquote>

<pre class="highlight"><code class=" hljs r">    class c {
        int a();
        int b();
        int c();
        // <span class="hljs-keyword">...</span>
        int l();
        int m();
        int n();
        // <span class="hljs-keyword">...</span>
        int x();
        int y();
        int z();
        int aa();
        int ab();
        int ac();
        int ad();
        int ae();
    };</code></pre>

<h4 id="10too-many-parameters">10ã€too many parameters</h4>

<p>&nbsp; &nbsp; &nbsp;  <code>Since:0.7</code> <a href="https://github.com/oclint/oclint/blob/master/oclint-rules/rules/size/TooManyParametersRule.cpp" rel="nofollow">å®šä¹‰ç±»ä¼ é€é—¨ï½ç‚¹å‡»</a></p>

<blockquote>
  <p>Methods with too many parameters are hard to understand and maintain, and are thirsty for refactorings, like Replace Parameter With method, Introduce Parameter Object, or Preserve Whole Object.</p>
  
  <p>ç®€å•è§£é‡Šï¼š ä¸€ä¸ªæ–¹æ³•ä¸­å‚æ•°è¿‡å¤šã€‚</p>
</blockquote>

<pre class="highlight"><code class=" hljs cs">    <span class="hljs-keyword">void</span> example(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b, <span class="hljs-keyword">int</span> c, <span class="hljs-keyword">int</span> d, <span class="hljs-keyword">int</span> e, <span class="hljs-keyword">int</span> f,
        <span class="hljs-keyword">int</span> g, <span class="hljs-keyword">int</span> h, <span class="hljs-keyword">int</span> i, <span class="hljs-keyword">int</span> j, <span class="hljs-keyword">int</span> k, <span class="hljs-keyword">int</span> l) {
    }</code></pre>

<blockquote>
  <p>TOO_MANY_PARAMETERS The reporting threshold for too many parameters, default value is 10. </p>
  
  <p>References: <br />
  Fowler, Martin (1999). Refactoring: Improving the design of existing code. Addison Wesley.</p>
</blockquote>

<h1 id="oclintè§„åˆ™-redundant-éƒ¨åˆ†">OCLintè§„åˆ™ Redundant éƒ¨åˆ†</h1>

<h4 id="1redundant-conditional-operator">1ã€redundant conditional operator</h4>

<p>&nbsp; &nbsp; &nbsp;  <code>Since:0.6</code> <a href="https://github.com/oclint/oclint/blob/master/oclint-rules/rules/redundant/RedundantConditionalOperatorRule.cpp" rel="nofollow" target="_blank">å®šä¹‰ç±»ä¼ é€é—¨ï½ç‚¹å‡»</a></p>

<blockquote>
  <p>This rule detects three types of redundant conditional operators:</p>
  
  <ol>
  <li>true expression and false expression are returning true/false or false/true respectively; </li>
  <li>true expression and false expression are the same constant;</li>
  <li>true expression and false expression are the same variable expression.</li>
  </ol>
  
  <p>They are usually introduced by mistake, and should be simplified.</p>
  
  <p>ç®€å•è§£é‡Šï¼šå†—ä½™çš„æ¡ä»¶åˆ¤æ–­ä¼šé€ æˆä¸€äº›é”™è¯¯ï¼Œåº”è¯¥è®©å®ƒå˜å¾—ç®€æ´ã€‚</p>
  
  <p>æ¯”å¦‚ï¼š 1.<code>true</code>å¯¹åº”<code>true</code>ã€‚<code>false</code>å¯¹åº”<code>false</code>ã€‚</p>
  
  <p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;2 . <code>true</code>å¯¹åº”<code>false</code>ã€‚<code>false</code>å¯¹åº”<code>true</code>ã€‚</p>
  
  <p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;3 . <code>true</code>å’Œ<code>false</code>ä¸€è‡´ã€‚</p>
</blockquote>

<pre class="highlight"><code class=" hljs cs">    <span class="hljs-keyword">void</span> example(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b, <span class="hljs-keyword">int</span> c) {
        <span class="hljs-keyword">bool</span> b1 = a &gt; b ? <span class="hljs-keyword">true</span> : <span class="hljs-keyword">false</span>;     <span class="hljs-comment">// true/false: bool b1 = a &gt; b;</span>
        <span class="hljs-keyword">bool</span> b2 = a &gt; b ? <span class="hljs-keyword">false</span> : <span class="hljs-keyword">true</span>;     <span class="hljs-comment">// false/true: bool b2 = !(a &gt; b);</span>
        <span class="hljs-keyword">int</span> i1 = a &gt; b ? <span class="hljs-number">1</span> : <span class="hljs-number">1</span>;             <span class="hljs-comment">// same constant: int i1 = 1;</span>
        <span class="hljs-keyword">float</span> f1 = a &gt; b ? <span class="hljs-number">1.0</span> : <span class="hljs-number">1.00</span>;      <span class="hljs-comment">// equally constant: float f1 = 1.0;</span>
        <span class="hljs-keyword">int</span> i2 = a &gt; b ? c : c;             <span class="hljs-comment">// same variable: int i2 = c;</span>
    }</code></pre>

<h4 id="2redundant-if-statement">2ã€redundant if statement</h4>

<p>&nbsp; &nbsp; &nbsp;  <code>Since:0.4</code> <a href="https://github.com/oclint/oclint/blob/master/oclint-rules/rules/redundant/RedundantIfStatementRule.cpp" rel="nofollow" target="_blank">å®šä¹‰ç±»ä¼ é€é—¨ï½ç‚¹å‡»</a></p>

<blockquote>
  <p>This rule detects unnecessary if statements.</p>
  
  <p>ç®€å•è§£é‡Šï¼šå¤šä½™çš„ifåˆ¤æ–­ï¼Œå¯ä»¥çœç•¥ã€‚</p>
</blockquote>

<pre class="highlight"><code class=" hljs cs">    <span class="hljs-keyword">bool</span> example(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b) {
        <span class="hljs-keyword">if</span> (a == b)             <span class="hljs-comment">// this if statement is redundant</span>
        {
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;
        }  <span class="hljs-keyword">else</span>   {
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;
        }                       <span class="hljs-comment">// the entire method can be simplified to return a == b;</span>
    }</code></pre>

<h4 id="3redundant-local-variable">3ã€redundant local variable</h4>

<p>&nbsp; &nbsp; &nbsp;  <code>Since:0.4</code> <a href="https://github.com/oclint/oclint/blob/master/oclint-rules/rules/redundant/RedundantIfStatementRule.cpp" rel="nofollow" target="_blank">å®šä¹‰ç±»ä¼ é€é—¨ï½ç‚¹å‡»</a></p>

<blockquote>
  <p>This rule detects cases where a variable declaration is immediately followed by a return of that variable.</p>
  
  <p>ç®€å•è§£é‡Šï¼šå†—ä½™çš„å±€éƒ¨å˜é‡ï¼Œå¯ä»¥çœç•¥ï¼Œç›´æ¥<code>return</code>ã€‚</p>
</blockquote>

<pre class="highlight"><code class=" hljs cs">    <span class="hljs-keyword">int</span> example(<span class="hljs-keyword">int</span> a) {
        <span class="hljs-keyword">int</span> b = a * <span class="hljs-number">2</span>;
        <span class="hljs-keyword">return</span> b;   <span class="hljs-comment">// variable b is returned immediately after its declaration,</span>
    }</code></pre>

<h4 id="4redundant-nil-check">4ã€redundant nil check</h4>

<p>&nbsp; &nbsp; &nbsp;  <code>Since:0.7</code> <a href="https://github.com/oclint/oclint/blob/master/oclint-rules/rules/redundant/RedundantNilCheckRule.cpp" rel="nofollow" target="_blank">å®šä¹‰ç±»ä¼ é€é—¨ï½ç‚¹å‡»</a></p>

<blockquote>
  <p>C/C++-style null check in Objective-C like foo != nil &amp;&amp; [foo bar] is redundant, since sending a message to a nil object in this case simply returns a false-y value.</p>
  
  <p>ç®€å•è§£é‡Šï¼šåœ¨Cæˆ–è€…C++ä¸­é€‚ç”¨çš„åˆ¤ç©ºæ£€æŸ¥åœ¨OCä¸­æ˜¯å¤šä½™çš„ã€‚å› ä¸ºåœ¨OCä¸­å‘ç©ºå¯¹è±¡å‘é€æ¶ˆæ¯ä¼šè¿”å›falseå€¼ã€‚</p>
</blockquote>

<pre class="highlight"><code class=" hljs coffeescript">    + (<span class="hljs-reserved">void</span>)<span class="hljs-attribute">compare</span>:(A *)obj1 <span class="hljs-attribute">withOther</span>:(A *)obj2  {
        <span class="hljs-keyword">if</span> (obj1 &amp;&amp; [obj1 <span class="hljs-attribute">isEqualTo</span>:obj2]) <span class="hljs-regexp">//</span> <span class="hljs-keyword">if</span> ([obj1 <span class="hljs-attribute">isEqualTo</span>:obj2]) <span class="hljs-keyword">is</span> okay   {
        }
    }</code></pre>

<h4 id="5-unnecessary-else-statement">5ã€ unnecessary else statement</h4>

<p>&nbsp; &nbsp; &nbsp;  <code>Since:0.6</code> <a href="https://github.com/oclint/oclint/blob/master/oclint-rules/rules/redundant/UnnecessaryElseStatementRule.cpp" rel="nofollow" target="_blank">å®šä¹‰ç±»ä¼ é€é—¨ï½ç‚¹å‡»</a></p>

<blockquote>
  <p>When an if statement block ends with a return statement, or all branches in the if statement block end with return statements, then the else statement is unnecessary. The code in the else statement can be run without being in the block.</p>
  
  <p>ç®€å•è§£é‡Šï¼šå¦‚æœifä¸­å·²ç»å¸¦æœ‰returnï¼Œåˆ™ä¸éœ€è¦å†™elseè¯­å¥ã€‚</p>
</blockquote>

<pre class="highlight"><code class=" hljs cpp">    <span class="hljs-keyword">bool</span> example(<span class="hljs-keyword">int</span> a) {
        <span class="hljs-keyword">if</span> (a == <span class="hljs-number">1</span>)                 <span class="hljs-comment">// if (a == 1)</span>
        {                           <span class="hljs-comment">// {</span>
            <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"a is 1."</span>;      <span class="hljs-comment">//     cout &lt;&lt; "a is 1.";</span>
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;            <span class="hljs-comment">//     return true;</span>
        }                           <span class="hljs-comment">// }</span>
        <span class="hljs-keyword">else</span>                        <span class="hljs-comment">//</span>
        {                           <span class="hljs-comment">//</span>
            <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"a is not 1."</span>   <span class="hljs-comment">// cout &lt;&lt; "a is not 1."</span>
        }                           <span class="hljs-comment">//</span>
    }
</code></pre>

<h4 id="6unnecessary-null-check-for-dealloc">6ã€unnecessary null check for dealloc</h4>

<p>&nbsp; &nbsp; &nbsp;  <code>Since:0.8</code> <a href="https://github.com/oclint/oclint/blob/master/oclint-rules/rules/redundant/UnnecessaryNullCheckForCXXDeallocRule.cpp" rel="nofollow" target="_blank">å®šä¹‰ç±»ä¼ é€é—¨ï½ç‚¹å‡»</a></p>

<blockquote>
  <p>char* p = 0; delete p;isvalid.Thisrulelocatesunnecessaryif (p)checks.</p>
  
  <p>ç®€å•è§£é‡Šï¼šåœ¨deallocä¸­ä¸éœ€è¦åˆ¤ç©ºï¼Œå°±èƒ½Deleteå…ƒç´ ã€‚</p>
</blockquote>

<pre class="highlight"><code class=" hljs cpp">    <span class="hljs-keyword">void</span> m(<span class="hljs-keyword">char</span>* c) {
        <span class="hljs-keyword">if</span> (c != <span class="hljs-keyword">nullptr</span>) { <span class="hljs-comment">// and be simplified to delete c;</span>
            <span class="hljs-keyword">delete</span> c;
        }
    }</code></pre>

<h4 id="7-useless-parentheses">7ã€ useless parentheses</h4>

<p>&nbsp; &nbsp; &nbsp;  <code>Since:0.6</code> <a href="https://github.com/oclint/oclint/blob/master/oclint-rules/rules/redundant/UselessParenthesesRule.cpp" rel="nofollow" target="_blank">å®šä¹‰ç±»ä¼ é€é—¨ï½ç‚¹å‡»</a></p>

<blockquote>
  <p>This rule detects useless parentheses.</p>
  
  <p>ç®€å•è§£é‡Šï¼šæ£€æŸ¥æ— ç”¨çš„æ‹¬å·ã€‚</p>
</blockquote>

<pre class="highlight"><code class=" hljs cs">    <span class="hljs-keyword">int</span> example(<span class="hljs-keyword">int</span> a) {
        <span class="hljs-keyword">int</span> y = (a + <span class="hljs-number">1</span>);    <span class="hljs-comment">// int y = a + 1;</span>
        <span class="hljs-keyword">if</span> ((y &gt; <span class="hljs-number">0</span>))        <span class="hljs-comment">// if (y &gt; 0)</span>
        {
            <span class="hljs-keyword">return</span> a;
        }
        <span class="hljs-keyword">return</span> (<span class="hljs-number">0</span>);         <span class="hljs-comment">// return 0;</span>
    }</code></pre>

<blockquote>
  <p><font color="red">PSï¼š</font>æ£€æµ‹äº†ä¸€ä¸‹åœ¨æ‹¬å·é‡Œæ˜¯é€»è¾‘åˆ¤æ–­æ—¶ä¸ä¼šè¢«æ£€æµ‹åˆ°,å¦‚ä¸‹ï¼ˆä¸ä¼šè¢«æ£€æŸ¥åˆ°ï¼‰ï¼š</p>
</blockquote>

<pre class="highlight"><code class=" hljs objectivec">    <span class="hljs-built_in">BOOL</span> aaaa = <span class="hljs-literal">YES</span>;
    <span class="hljs-built_in">BOOL</span> bbbb = <span class="hljs-literal">NO</span>;
     <span class="hljs-keyword">if</span>((aaaa) &amp;&amp; (bbbb)) {
        <span class="hljs-keyword">return</span> <span class="hljs-literal">YES</span>;
      }</code></pre>

<h1 id="oclintè§„åˆ™-naming-éƒ¨åˆ†">OCLintè§„åˆ™ Naming éƒ¨åˆ†</h1>

<h4 id="1long-variable-name">1ã€long variable name</h4>

<p>&nbsp; &nbsp; &nbsp;  <code>Since:0.7</code> <a href="https://github.com/oclint/oclint/blob/master/oclint-rules/rules/naming/LongVariableNameRule.cpp" rel="nofollow" target="_blank">å®šä¹‰ç±»ä¼ é€é—¨ï½ç‚¹å‡»</a></p>

<blockquote>
  <p>Variables with long names harm readability.</p>
  
  <p>ç®€å•è§£é‡Šï¼šå˜é‡åè¾ƒé•¿ï¼Œå½±å“å¯è¯»æ€§ã€‚</p>
</blockquote>

<pre class="highlight"><code class=" hljs cs">    <span class="hljs-keyword">void</span> aMethod() {
        <span class="hljs-keyword">int</span> reallyReallyLongIntegerName;
    }</code></pre>

<blockquote>
  <p>Thresholds: <br />
  LONG_VARIABLE_NAME The long variable name reporting threshold, default value is 20.</p>
</blockquote>

<h4 id="2hort-variable-name">2ã€hort variable name</h4>

<p>&nbsp; &nbsp; &nbsp;  <code>Since:0.7</code> <a href="https://github.com/oclint/oclint/blob/master/oclint-rules/rules/naming/ShortVariableNameRule.cpp" rel="nofollow" target="_blank">å®šä¹‰ç±»ä¼ é€é—¨ï½ç‚¹å‡»</a></p>

<blockquote>
  <p>A variable with a short name is hard to understand what it stands for. Variable with name, but the name has number of characters less than the threshold will be emitted.</p>
  
  <p>ç®€å•è§£é‡Šï¼šå˜é‡åå¤ªçŸ­ï¼Œå½±å“å¯è¯»æ€§ã€‚</p>
</blockquote>

<pre class="highlight"><code class=" hljs cs">    <span class="hljs-keyword">void</span> aMethod(<span class="hljs-keyword">int</span> i)  <span class="hljs-comment">// i is short</span>
    {
        <span class="hljs-keyword">int</span> ii;          <span class="hljs-comment">// ii is short</span>
    }</code></pre>

<blockquote>
  <p>Thresholds: <br />
  SHORT_VARIABLE_NAME The short variable name reporting threshold, default value is 3.</p>
</blockquote>

<h1 id="oclintè§„åˆ™-migration-éƒ¨åˆ†">OCLintè§„åˆ™ Migration éƒ¨åˆ†</h1>

<h4 id="1use-boxed-expression">1ã€use boxed expression</h4>

<p>&nbsp; &nbsp; &nbsp;  <code>Since:0.7</code> <a href="https://github.com/oclint/oclint/blob/master/oclint-rules/rules/migration/ObjCBoxedExpressionsRule.cpp" rel="nofollow" target="_blank">å®šä¹‰ç±»ä¼ é€é—¨ï½ç‚¹å‡»</a></p>

<blockquote>
  <p>This rule locates the places that can be migrated to the new Objective-C literals with boxed expressions.</p>
  
  <p>ç®€å•è§£é‡Šï¼šå»ºè®®ä½¿ç”¨æ–°æ–¹æ³•ï¼Œå¿«é€Ÿåˆ›å»ºï¼ˆ<code>numberWithInt</code>å’Œ<code>stringWithUTF8String:</code>ï¼‰ã€‚</p>
</blockquote>

<pre class="highlight"><code class=" hljs objectivec">    <span class="hljs-keyword">void</span> aMethod() {
        <span class="hljs-built_in">NSNumber</span> *fortyTwo = [<span class="hljs-built_in">NSNumber</span> numberWithInt:(<span class="hljs-number">43</span> - <span class="hljs-number">1</span>)];
        <span class="hljs-comment">// NSNumber *fortyTwo = @(43 - 1);</span>
        <span class="hljs-built_in">NSString</span> *env = [<span class="hljs-built_in">NSString</span> stringWithUTF8String:getenv(<span class="hljs-string">"PATH"</span>)];
        <span class="hljs-comment">// NSString *env = @(getenv("PATH"));</span>
    }</code></pre>

<h4 id="2-use-container-literal">2ã€ use container literal</h4>

<p>&nbsp; &nbsp; &nbsp;  <code>Since:0.7</code> <a href="https://github.com/oclint/oclint/blob/master/oclint-rules/rules/migration/ObjCContainerLiteralsRule.cpp" rel="nofollow" target="_blank">å®šä¹‰ç±»ä¼ é€é—¨ï½ç‚¹å‡»</a></p>

<blockquote>
  <p>This rule locates the places that can be migrated to the new Objective-C literals with container literals.</p>
  
  <p>ç®€å•è§£é‡Šï¼šå»ºè®®ä½¿ç”¨æ–°æ–¹æ³•ï¼Œå¿«é€Ÿåˆ›å»ºï¼ˆ<code>arrayWithObjects</code>å’Œ<code>dictionaryWithObjects</code>ï¼‰ã€‚</p>
</blockquote>

<pre class="highlight"><code class=" hljs perl">    void aMethod()
    {
        NSArray <span class="hljs-variable">*a</span> = [NSArray arrayWithObjects:<span class="hljs-variable">@1</span>, <span class="hljs-variable">@2</span>, <span class="hljs-variable">@3</span>, nil];
        <span class="hljs-regexp">//</span> NSArray <span class="hljs-variable">*a</span> = <span class="hljs-variable">@[</span> <span class="hljs-variable">@1</span>, <span class="hljs-variable">@2</span>, <span class="hljs-variable">@3</span> ];
        NSDictionary <span class="hljs-variable">*d</span> = [NSDictionary dictionaryWithObjects:<span class="hljs-variable">@[</span><span class="hljs-variable">@2</span>,<span class="hljs-variable">@4</span>] forKeys:<span class="hljs-variable">@[</span><span class="hljs-variable">@1</span>,<span class="hljs-variable">@3</span>]];
        <span class="hljs-regexp">//</span> NSDictionary <span class="hljs-variable">*d</span> = @{ <span class="hljs-variable">@1</span> : <span class="hljs-variable">@2</span>, <span class="hljs-variable">@3</span> : <span class="hljs-variable">@4</span> };
    }</code></pre>

<h4 id="3use-number-literal">3ã€use number literal</h4>

<p>&nbsp; &nbsp; &nbsp;  <code>Since:0.7</code> <a href="https://github.com/oclint/oclint/blob/master/oclint-rules/rules/migration/ObjCNSNumberLiteralsRule.cpp" rel="nofollow" target="_blank">å®šä¹‰ç±»ä¼ é€é—¨ï½ç‚¹å‡»</a></p>

<blockquote>
  <p>This rule locates the places that can be migrated to the new Objective-C literals with number literals.</p>
  
  <p>ç®€å•è§£é‡Šï¼šå»ºè®®ä½¿ç”¨æ–°æ–¹æ³•ï¼Œå¿«é€Ÿåˆ›å»ºï¼ˆ<code>numberWithInt</code>å’Œ<code>numberWithBOOL</code>ï¼‰ã€‚</p>
</blockquote>

<pre class="highlight"><code class=" hljs objectivec">    <span class="hljs-keyword">void</span> aMethod() {
        <span class="hljs-built_in">NSNumber</span> *fortyTwo = [<span class="hljs-built_in">NSNumber</span> numberWithInt:<span class="hljs-number">42</span>];
        <span class="hljs-comment">// NSNumber *fortyTwo = @42;</span>
        <span class="hljs-built_in">NSNumber</span> *yesBool = [<span class="hljs-built_in">NSNumber</span> numberWithBool:<span class="hljs-literal">YES</span>];
        <span class="hljs-comment">// NSNumber *yesBool = @YES;</span>
    }</code></pre>

<h4 id="4use-object-subscripting">4ã€use object subscripting</h4>

<p>&nbsp; &nbsp; &nbsp;  <code>Since:0.7</code> <a href="https://github.com/oclint/oclint/blob/master/oclint-rules/rules/migration/ObjCObjectSubscriptingRule.cpp" rel="nofollow" target="_blank">å®šä¹‰ç±»ä¼ é€é—¨ï½ç‚¹å‡»</a></p>

<blockquote>
  <p>This rule locates the places that can be migrated to the new Objective-C literals with object subscripting.</p>
  
  <p>ç®€å•è§£é‡Šï¼šå»ºè®®ä½¿ç”¨æ–°æ–¹æ³•ï¼Œå¿«é€Ÿåˆ›å»ºï¼ˆ<code>objectAtIndex</code>å’Œ<code>objectForKey</code>ï¼‰ã€‚</p>
</blockquote>

<pre class="highlight"><code class=" hljs objectivec">    <span class="hljs-keyword">void</span> aMethod(<span class="hljs-built_in">NSArray</span> *a, <span class="hljs-built_in">NSDictionary</span> *d) {
        <span class="hljs-keyword">id</span> item = [a objectAtIndex:<span class="hljs-number">0</span>];
        <span class="hljs-comment">// id item = a[0];</span>
        <span class="hljs-keyword">id</span> item = [d objectForKey:@<span class="hljs-number">1</span>];
        <span class="hljs-comment">// id item = d[@1];</span>
    }</code></pre>

<h1 id="oclintè§„åˆ™-empty-éƒ¨åˆ†">OCLintè§„åˆ™ Empty éƒ¨åˆ†</h1>

<h4 id="1empty-catch-statement">1ã€empty catch statement</h4>

<p>&nbsp; &nbsp; &nbsp;  <code>Since:0.6</code> <a href="https://github.com/oclint/oclint/blob/master/oclint-rules/rules/empty/EmptyCatchStatementRule.cpp" rel="nofollow" target="_blank">å®šä¹‰ç±»ä¼ é€é—¨ï½ç‚¹å‡»</a></p>

<blockquote>
  <p>This rule detects instances where an exception is caught, but nothing is done about it.</p>
  
  <p>ç®€å•è§£é‡Šï¼šæ•è·äº†å¼‚å¸¸ï¼Œåœ¨Catchä¸­ä»€ä¹ˆéƒ½æ²¡æœ‰åšçš„æƒ…å†µã€‚</p>
</blockquote>

<pre class="highlight"><code class=" hljs r">    void example()  {
        <span class="hljs-keyword">try</span> {
            int* m= new int[<span class="hljs-number">1000</span>];
        }
        catch(<span class="hljs-keyword">...</span>)                  // empty catch statement, this swallows an exception
        {
        }
    }</code></pre>

<h4 id="2empty-dowhile-statement">2ã€empty do/while statement</h4>

<p>&nbsp; &nbsp; &nbsp;  <code>Since:0.6</code> <a href="https://github.com/oclint/oclint/blob/master/oclint-rules/rules/empty/EmptyDoWhileStatementRule.cpp" rel="nofollow" target="_blank">å®šä¹‰ç±»ä¼ é€é—¨ï½ç‚¹å‡»</a></p>

<blockquote>
  <p>This rule detects instances where do-while statement does nothing.</p>
  
  <p>ç®€å•è§£é‡Šï¼šç©ºçš„<code>do-while</code>æ£€æŸ¥ã€‚</p>
</blockquote>

<pre class="highlight"><code class=" hljs ruby">    void example() {
        <span class="hljs-keyword">do</span>
        {                           <span class="hljs-regexp">//</span> empty <span class="hljs-keyword">do</span>-<span class="hljs-keyword">while</span> statement
        } <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>);
    }</code></pre>

<h4 id="3empty-else-block">3ã€empty else block</h4>

<p>&nbsp; &nbsp; &nbsp;  <code>Since:0.6</code> <a href="https://github.com/oclint/oclint/blob/master/oclint-rules/rules/empty/EmptyElseBlockRule.cpp" rel="nofollow" target="_blank">å®šä¹‰ç±»ä¼ é€é—¨ï½ç‚¹å‡»</a></p>

<blockquote>
  <p>This rule detects instances where a else statement does nothing.</p>
  
  <p>ç®€å•è§£é‡Šï¼šç©ºçš„<code>else</code>æ£€æŸ¥ã€‚</p>
</blockquote>

<pre class="highlight"><code class=" hljs cs">    <span class="hljs-keyword">int</span> example(<span class="hljs-keyword">int</span> a)  {
        <span class="hljs-keyword">if</span> (<span class="hljs-number">1</span>)  {
            <span class="hljs-keyword">return</span> a + <span class="hljs-number">1</span>;
        }  <span class="hljs-keyword">else</span>  {               <span class="hljs-comment">// empty else statement, can be safely removed</span>
        }
    }</code></pre>

<h4 id="4empty-finally-statement">4ã€empty finally statement</h4>

<p>&nbsp; &nbsp; &nbsp;  <code>Since:0.6</code> <a href="https://github.com/oclint/oclint/blob/master/oclint-rules/rules/empty/EmptyFinallyStatementRule.cpp" rel="nofollow" target="_blank">å®šä¹‰ç±»ä¼ é€é—¨ï½ç‚¹å‡»</a></p>

<blockquote>
  <p>This rule detects instances where a finally statement does nothing.</p>
  
  <p>ç®€å•è§£é‡Šï¼šç©ºçš„<code>finally</code>æ£€æŸ¥ã€‚</p>
</blockquote>

<pre class="highlight"><code class=" hljs objectivec">    <span class="hljs-keyword">void</span> example() {
        Foo *foo;
        <span class="hljs-keyword">@try</span> {
            [foo bar];
        }
        <span class="hljs-keyword">@catch</span>(<span class="hljs-built_in">NSException</span> *e) {
            <span class="hljs-built_in">NSLog</span>(@<span class="hljs-string">"Exception occurred: %@"</span>, [e description]);
        }
        <span class="hljs-keyword">@finally</span>            <span class="hljs-comment">// empty finally statement, probably forget to clean up?</span>
        {
        }
    }</code></pre>

<h4 id="5empty-for-statement">5ã€empty for statement</h4>

<p>&nbsp; &nbsp; &nbsp;  <code>Since:0.6</code> <a href="https://github.com/oclint/oclint/blob/master/oclint-rules/rules/empty/EmptyForStatementRule.cpp" rel="nofollow" target="_blank">å®šä¹‰ç±»ä¼ é€é—¨ï½ç‚¹å‡»</a></p>

<blockquote>
  <p>This rule detects instances where a for statement does nothing.</p>
  
  <p>ç®€å•è§£é‡Šï¼šç©ºçš„<code>for</code>è¯­å¥æ£€æŸ¥ã€‚</p>
</blockquote>

<pre class="highlight"><code class=" hljs objectivec">    <span class="hljs-keyword">void</span> example(<span class="hljs-built_in">NSArray</span> *array) {
        <span class="hljs-keyword">for</span> (;;)                <span class="hljs-comment">// empty for statement</span>
        {
        }
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">id</span> it in array)    <span class="hljs-comment">// empty for-each statement</span>
        {
        }
    }</code></pre>

<h4 id="6empty-if-statement">6ã€empty if statement</h4>

<p>&nbsp; &nbsp; &nbsp;  <code>Since:0.2</code> <a href="https://github.com/oclint/oclint/blob/master/oclint-rules/rules/empty/EmptyIfStatementRule.cpp" rel="nofollow" target="_blank">å®šä¹‰ç±»ä¼ é€é—¨ï½ç‚¹å‡»</a></p>

<blockquote>
  <p>This rule detects instances where a condition is checked, but nothing is done about it.</p>
  
  <p>ç®€å•è§£é‡Šï¼šç©ºçš„<code>if</code>æ£€æŸ¥ã€‚</p>
</blockquote>

<pre class="highlight"><code class=" hljs cs">    <span class="hljs-keyword">void</span> example(<span class="hljs-keyword">int</span> a) {
        <span class="hljs-keyword">if</span> (a == <span class="hljs-number">1</span>)                  <span class="hljs-comment">// empty if statement</span>
        {
        }
    }</code></pre>

<h4 id="7empty-switch-statement">7ã€empty switch statement</h4>

<p>&nbsp; &nbsp; &nbsp;  <code>Since:0.6</code> <a href="https://github.com/oclint/oclint/blob/master/oclint-rules/rules/empty/EmptySwitchStatementRule.cpp" rel="nofollow" target="_blank">å®šä¹‰ç±»ä¼ é€é—¨ï½ç‚¹å‡»</a></p>

<blockquote>
  <p>This rule detects instances where a switch statement does nothing.</p>
  
  <p>ç®€å•è§£é‡Šï¼šç©ºçš„<code>switch</code>æ£€æŸ¥ã€‚</p>
</blockquote>

<pre class="highlight"><code class=" hljs cs">    <span class="hljs-keyword">void</span> example(<span class="hljs-keyword">int</span> i) {
        <span class="hljs-keyword">switch</span> (i)              <span class="hljs-comment">// empty switch statement</span>
        {
        }
    }</code></pre>

<h4 id="8empty-try-statement">8ã€empty try statement</h4>

<p>&nbsp; &nbsp; &nbsp;  <code>Since:0.6</code> <a href="https://github.com/oclint/oclint/blob/master/oclint-rules/rules/empty/EmptyTryStatementRule.cpp" rel="nofollow" target="_blank">å®šä¹‰ç±»ä¼ é€é—¨ï½ç‚¹å‡»</a></p>

<blockquote>
  <p>This rule detects instances where a try statement is empty.</p>
  
  <p>ç®€å•è§£é‡Šï¼šç©ºçš„<code>try</code>æ£€æŸ¥ã€‚</p>
</blockquote>

<pre class="highlight"><code class=" hljs r">    void example() {
        <span class="hljs-keyword">try</span>                     // but this <span class="hljs-keyword">try</span> statement is empty
        {
        }
        catch(<span class="hljs-keyword">...</span>) {
            cout &lt;&lt; <span class="hljs-string">"Exception is caught!"</span>;
        }
    }
</code></pre>

<h4 id="9-empty-while-statement">9ã€ empty while statement</h4>

<p>&nbsp; &nbsp; &nbsp;  <code>Since:0.6</code> <a href="https://github.com/oclint/oclint/blob/master/oclint-rules/rules/empty/EmptyWhileStatementRule.cpp" rel="nofollow" target="_blank">å®šä¹‰ç±»ä¼ é€é—¨ï½ç‚¹å‡»</a></p>

<blockquote>
  <p>This rule detects instances where a while statement does nothing.</p>
  
  <p>ç®€å•è§£é‡Šï¼šç©ºçš„<code>while</code>æ£€æŸ¥ã€‚</p>
</blockquote>

<pre class="highlight"><code class=" hljs cs">    <span class="hljs-keyword">void</span> example(<span class="hljs-keyword">int</span> a {
        <span class="hljs-keyword">while</span>(a--)              <span class="hljs-comment">// empty while statement</span>
        {
        }
    }</code></pre>

<h1 id="oclintè§„åˆ™-design-éƒ¨åˆ†">OCLintè§„åˆ™ Design éƒ¨åˆ†</h1>

<h4 id="1avoid-default-arguments-on-virtual-methods">1ã€avoid default arguments on virtual methods</h4>

<p>&nbsp; &nbsp; &nbsp;  <code>Since:0.10.1</code> <a href="https://github.com/oclint/oclint/blob/master/oclint-rules/rules/design/AvoidDefaultArgumentsOnVirtualMethodsRule.cpp" rel="nofollow" target="_blank">å®šä¹‰ç±»ä¼ é€é—¨ï½ç‚¹å‡»</a></p>

<blockquote>
  <p>Giving virtual functions default argument initializers tends to defeat polymorphism and introduce unnecessary com- plexity into a class hierarchy.</p>
  
  <p>ç®€å•è§£é‡Šï¼šé¿å…ç»™è™šå‡½æ•°è®¾ç½®é»˜è®¤å‚æ•°ï¼Œç»™è™šå‡½æ•°è®¾ç½®é»˜è®¤å‚æ•°ä¼šç ´åå¤šæ ·æ€§å’Œå¼•èµ·ä¸å¿…è¦çš„å±‚æ¬¡ç»“æ„å‘æ‚æ€§ã€‚</p>
</blockquote>

<pre class="highlight"><code class=" hljs r">    class Foo
    {
    public:
        virtual ~Foo();
        virtual void a(int b = <span class="hljs-number">3</span>);
        // <span class="hljs-keyword">...</span>
    };
    class Bar : public Foo
    {
    public:
        void a(int b);
        // <span class="hljs-keyword">...</span>
    };
    Bar *bar = new Bar;
    Foo *foo = bar;
    foo-&gt;a();   // default of <span class="hljs-number">3</span>
    bar-&gt;a();   // compile time error!</code></pre>

<h4 id="2avoid-private-static-members">2ã€avoid private static members</h4>

<p>&nbsp; &nbsp; &nbsp;  <code>Since:0.10.1</code> <a href="https://github.com/oclint/oclint/blob/master/oclint-rules/rules/design/AvoidPrivateStaticMembersRule.cpp" rel="nofollow" target="_blank">å®šä¹‰ç±»ä¼ é€é—¨ï½ç‚¹å‡»</a></p>

<blockquote>
  <p>Having static members is easier to harm encapsulation.</p>
  
  <p>ç®€å•è§£é‡Šï¼šé¿å…ä½¿ç”¨ç§æœ‰é™æ€æˆå‘˜ï¼Œé™æ€æˆå‘˜å¾ˆå®¹æ˜“ç ´æ¢å°è£…æ€§</p>
</blockquote>

<pre class="highlight"><code class=" hljs vala">    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Foo</span> {</span>
        <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> a;       <span class="hljs-comment">// static field</span>
    };
    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Bar</span> {</span>
        <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> b();     <span class="hljs-comment">// static method</span>
    }</code></pre>

<h1 id="oclintè§„åˆ™-convention-éƒ¨åˆ†">OCLintè§„åˆ™ Convention éƒ¨åˆ†</h1>

<h4 id="1avoid-branching-statement-as-last-in-loop">1ã€avoid branching statement as last in loop</h4>

<p>&nbsp; &nbsp; &nbsp;  <code>Since:0.7</code> <a href="https://github.com/oclint/oclint/blob/master/oclint-rules/rules/convention/AvoidBranchingStatementAsLastInLoopRule.cpp" rel="nofollow" target="_blank">å®šä¹‰ç±»ä¼ é€é—¨ï½ç‚¹å‡»</a></p>

<blockquote>
  <p>Having branching statement as the last statement inside a loop is very confusing, and could largely be forgetting of something and turning into a bug.</p>
  
  <p>ç®€å•è§£é‡Šï¼šä¸è¦å†å¾ªç¯æœ€ååŠ å…¥åˆ†æ”¯ï¼Œè´Ÿè´£ç†è§£èµ·æ¥æ¯”è¾ƒå›°éš¾ï¼Œå¾ˆå¤§ç¨‹åº¦ä¸Šä¼šé—å¿˜ä¸€äº›äº‹æƒ…ï¼Œå¯¼è‡´ä¸€äº›é”™è¯¯ã€‚</p>
</blockquote>

<pre class="highlight"><code class=" hljs coffeescript">    <span class="hljs-reserved">void</span> example() {
        <span class="hljs-keyword">for</span> (int i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) {
            <span class="hljs-keyword">if</span> (foo(i)) {
                <span class="hljs-keyword">continue</span>;
            }
            <span class="hljs-keyword">break</span>;      <span class="hljs-regexp">//</span> <span class="hljs-keyword">this</span> <span class="hljs-keyword">break</span> <span class="hljs-keyword">is</span> confusing
        }
    }</code></pre>

<h4 id="2base-class-destructor-should-be-virtual-or-protected">2ã€base class destructor should be virtual or protected</h4>

<p>&nbsp; &nbsp; &nbsp;  <code>Since:0.10.2</code> <a href="https://github.com/oclint/oclint/blob/master/oclint-rules/rules/convention/BaseClassDestructorShouldBeVirtualOrProtectedRule.cpp" rel="nofollow" target="_blank">å®šä¹‰ç±»ä¼ é€é—¨ï½ç‚¹å‡»</a></p>

<blockquote>
  <p>Make base class destructor public and virtual, or protected and nonvirtual</p>
  
  <p>ç®€å•è§£é‡Šï¼šåŸºç±»çš„ææ„å‡½æ•°éœ€è¦æ˜¯<code>public</code>ã€<code>virtual</code>æˆ–è€…<code>protected``nonvirtual</code>ã€‚</p>
</blockquote>

<pre class="highlight"><code class=" hljs cs">    class Base {
    <span class="hljs-keyword">public</span>:
        ~<span class="hljs-title">Base</span>(); <span class="hljs-comment">// this should be either protected or virtual</span>
    }
    class C : <span class="hljs-keyword">public</span> Base {
        <span class="hljs-keyword">virtual</span> ~C();
    }</code></pre>

<p>Sutter &amp; Alexandrescu (November 2004). [<code>â€œC++ Coding Standards: 101 Rules, Guidelines, and Best Practicesâ€</code>(<a href="http://gotw.ca/publications/c++cs.htm)]" rel="nofollow" target="_blank">http://gotw.ca/publications/c++cs.htm)]</a>. Addison-Wesley Professional</p>

<h4 id="3unnecessary-default-statement-in-covered-switch-statement">3ã€unnecessary default statement in covered switch statement</h4>

<p>&nbsp; &nbsp; &nbsp;  <code>Since:0.8</code> <a href="https://github.com/oclint/oclint/blob/master/oclint-rules/rules/convention/CoveredSwitchStatementsDontNeedDefaultRule.cpp" rel="nofollow" target="_blank">å®šä¹‰ç±»ä¼ é€é—¨ï½ç‚¹å‡»</a></p>

<blockquote>
  <p>When a switch statement covers all possible cases, a default label is not needed and should be removed. If the switch is not fully covered, the SwitchStatements Should Have Default rule will report.</p>
  
  <p>ç®€å•è§£é‡Šï¼šå¦‚æœ<code>switch</code>è¦†ç›–äº†æ‰€æœ‰çš„æ¡ä»¶ï¼Œ<code>default</code>æ˜¯ä¸éœ€è¦çš„åº”è¯¥è¢«ç§»é™¤ã€‚å¦‚æœä¸æ˜¯<code>default</code>è¿˜æ˜¯éœ€è¦çš„ã€‚</p>
</blockquote>

<pre class="highlight"><code class=" hljs d">    <span class="hljs-keyword">typedef</span> <span class="hljs-keyword">enum</span> {
        value1 = <span class="hljs-number">0</span>,
        value2 = <span class="hljs-number">1</span>
    } eValues;
    <span class="hljs-comment">//</span>
    <span class="hljs-keyword">void</span> aMethod(eValues a)
    {
        <span class="hljs-keyword">switch</span>(a)
        {
            <span class="hljs-keyword">case</span> value1:
                <span class="hljs-keyword">break</span>;
            <span class="hljs-keyword">case</span> value2:
                <span class="hljs-keyword">break</span>;
            <span class="hljs-keyword">default</span>:          <span class="hljs-comment">// this break is obsolete because all</span>
                <span class="hljs-keyword">break</span>;        <span class="hljs-comment">// values of variable a are already covered.</span>
        }
    }</code></pre>

<h4 id="4-ill-placed-default-label-in-switch-statement">4ã€ ill-placed default label in switch statement</h4>

<p>&nbsp; &nbsp; &nbsp;  <code>Since:0.6</code> <a href="https://github.com/oclint/oclint/blob/master/oclint-rules/rules/convention/DefaultLabelNotLastInSwitchStatementRule.cpp" rel="nofollow" target="_blank">å®šä¹‰ç±»ä¼ é€é—¨ï½ç‚¹å‡»</a></p>

<blockquote>
  <p>It is very confusing when default label is not the last label in a switch statement.</p>
  
  <p>ç®€å•è§£é‡Šï¼š<code>default</code>åº”è¯¥åœ¨<code>switch</code>çš„æœ€åï¼Œè´Ÿè´£ä¼šå¾ˆéš¾ç†è§£ã€‚</p>
</blockquote>

<pre class="highlight"><code class=" hljs cs">    <span class="hljs-keyword">void</span> example(<span class="hljs-keyword">int</span> a) {
        <span class="hljs-keyword">switch</span> (a) {
            <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:
                <span class="hljs-keyword">break</span>;
            <span class="hljs-keyword">default</span>:  <span class="hljs-comment">// the default case should be last</span>
                <span class="hljs-keyword">break</span>;
            <span class="hljs-keyword">case</span> <span class="hljs-number">2</span>:
                <span class="hljs-keyword">break</span>;
        }
    }</code></pre>

<h4 id="5destructor-of-virtual-class">5ã€destructor of virtual class</h4>

<p>&nbsp; &nbsp; &nbsp;  <code>Since:0.8</code> <a href="https://github.com/oclint/oclint/blob/master/oclint-rules/rules/convention/DestructorOfVirtualClassRule.cpp" rel="nofollow" target="_blank">å®šä¹‰ç±»ä¼ é€é—¨ï½ç‚¹å‡»</a></p>

<blockquote>
  <p>This rule enforces the destructor of a virtual class must be virtual.</p>
  
  <p>ç®€å•è§£é‡Šï¼šè¿™ä¸ªè§„åˆ™æ˜¯è™šæ‹Ÿç±»çš„ææ„å‡½æ•°å¿…é¡»æ˜¯è™šæ‹Ÿçš„ã€‚</p>
</blockquote>

<pre class="highlight"><code class=" hljs cs">    class Base { <span class="hljs-comment">// class Base should have a virtual destructor ~Base()</span>
        <span class="hljs-keyword">public</span>: <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">f</span>();
    };
    class Child : <span class="hljs-keyword">public</span> Base {
        <span class="hljs-keyword">public</span>: ~<span class="hljs-title">Child</span>();  <span class="hljs-comment">// destructor ~Child() should be virtual</span>
    };</code></pre>

<h4 id="6inverted-logic">6ã€inverted logic</h4>

<p>&nbsp; &nbsp; &nbsp;  <code>Since:0.4</code> <a href="https://github.com/oclint/oclint/blob/master/oclint-rules/rules/convention/InvertedLogicRule.cpp" rel="nofollow" target="_blank">å®šä¹‰ç±»ä¼ é€é—¨ï½ç‚¹å‡»</a></p>

<blockquote>
  <p>An inverted logic is hard to understand.</p>
  
  <p>ç®€å•è§£é‡Šï¼šå€’ç½®é€»è¾‘ä¸æ˜“ç†è§£ã€‚</p>
</blockquote>

<pre class="highlight"><code class=" hljs cs">    <span class="hljs-keyword">int</span> example(<span class="hljs-keyword">int</span> a) {
        <span class="hljs-keyword">int</span> i;
        <span class="hljs-keyword">if</span> (a != <span class="hljs-number">0</span>)             <span class="hljs-comment">// if (a == 0)</span>
        {                       <span class="hljs-comment">// {</span>
            i = <span class="hljs-number">1</span>;              <span class="hljs-comment">//      i = 0;</span>
        }                       <span class="hljs-comment">// }</span>
        <span class="hljs-keyword">else</span>                    <span class="hljs-comment">// else</span>
        {                       <span class="hljs-comment">// {</span>
            i = <span class="hljs-number">0</span>;              <span class="hljs-comment">//      i = 1;</span>
        }                       <span class="hljs-comment">// }</span>
        <span class="hljs-keyword">return</span> !i ? -<span class="hljs-number">1</span> : <span class="hljs-number">1</span>;     <span class="hljs-comment">// return i ? 1 : -1;</span>
    }</code></pre>

<blockquote>
  <p><font color="red">PSï¼š</font>åœ¨åšåˆ¤æ–­çš„æ—¶å€™ï¼Œåº”è¯¥å…ˆåšçš„<code>æ˜¯</code>åˆ¤æ–­ï¼Œåœ¨åš<code>é</code>çš„åˆ¤æ–­ã€‚åšä¸ªä¸€ä¸ªæµ‹è¯•å¦‚æœåªæœ‰éçš„æµ‹è¯•æ˜¯ä¸ä¼šæœ‰è­¦å‘Šçš„ã€‚</p>
</blockquote>

<pre class="highlight"><code class=" hljs mel">    <span class="hljs-keyword">int</span> example(<span class="hljs-keyword">int</span> <span class="hljs-keyword">condition</span>) {
        <span class="hljs-keyword">int</span> temp;
        <span class="hljs-keyword">if</span> (acondition!= <span class="hljs-number">0</span>)            <span class="hljs-comment">//ä¸ä¼šæœ‰è­¦å‘Š</span>
        {                       
            temp = <span class="hljs-number">1</span>;            
        }                  
    }</code></pre>

<h4 id="7missing-break-in-switch-statement">7ã€missing break in switch statement</h4>

<p>&nbsp; &nbsp; &nbsp;  <code>Since:0.6</code> <a href="https://github.com/oclint/oclint/blob/master/oclint-rules/rules/convention/MissingBreakInSwitchStatementRule.cpp" rel="nofollow" target="_blank">å®šä¹‰ç±»ä¼ é€é—¨ï½ç‚¹å‡»</a></p>

<blockquote>
  <p>A switch statement without a break statement has a very large chance to contribute a bug.</p>
  
  <p>ç®€å•è§£é‡Šï¼šåœ¨<code>switch</code>è¯­å¥ä¸­ç¼ºå¤±äº†<code>break</code>ï¼Œå¾ˆæœ‰å¯èƒ½å¼•å‘<code>bug</code>ã€‚</p>
</blockquote>

<pre class="highlight"><code class=" hljs cs">    <span class="hljs-keyword">void</span> example(<span class="hljs-keyword">int</span> a) {
        <span class="hljs-keyword">switch</span> (a) {
            <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:
                <span class="hljs-keyword">break</span>;
            <span class="hljs-keyword">case</span> <span class="hljs-number">2</span>:
                <span class="hljs-comment">// do something</span>
            <span class="hljs-keyword">default</span>:
                <span class="hljs-keyword">break</span>;
        }
    }</code></pre>

<h4 id="8non-case-label-in-switch-statement-since06-å®šä¹‰ç±»ä¼ é€é—¨ç‚¹å‡»">8ã€non case label in switch statement              &nbsp; &nbsp; &nbsp;  <code>Since:0.6</code> <a href="https://github.com/oclint/oclint/blob/master/oclint-rules/rules/convention/NonCaseLabelInSwitchStatementRule.cpp" rel="nofollow" target="_blank">å®šä¹‰ç±»ä¼ é€é—¨ï½ç‚¹å‡»</a></h4>

<blockquote>
  <p>It is very confusing when label becomes part of the switch statement.</p>
  
  <p>ç®€å•è§£é‡Šï¼š<code>label</code>å‡ºç°åœ¨<code>switch</code>æ¡ä»¶ä¸­ä¸æ˜“ç†è§£ã€‚</p>
</blockquote>

<pre class="highlight"><code class=" hljs cs">    <span class="hljs-keyword">void</span> example(<span class="hljs-keyword">int</span> a) {
        <span class="hljs-keyword">switch</span> (a) {
            <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:
                <span class="hljs-keyword">break</span>;
            label1:     <span class="hljs-comment">// label in a switch statement in really confusing</span>
                <span class="hljs-keyword">break</span>;
            <span class="hljs-keyword">default</span>:
                <span class="hljs-keyword">break</span>;
        }
    }</code></pre>

<h4 id="9-ivar-assignment-outside-accessors-or-init-since08-å®šä¹‰ç±»ä¼ é€é—¨ç‚¹å‡»">9ã€ ivar assignment outside accessors or init      &nbsp; &nbsp; &nbsp;  <code>Since:0.8</code> <a href="https://github.com/oclint/oclint/blob/master/oclint-rules/rules/convention/ObjCAssignIvarOutsideAccessorsRule.cpp" rel="nofollow" target="_blank">å®šä¹‰ç±»ä¼ é€é—¨ï½ç‚¹å‡»</a></h4>

<blockquote>
  <p>This rule prevents assigning an ivar outside of getters, setters, and init method.</p>
  
  <p>ç®€å•è§£é‡Šï¼šæ£€æŸ¥æŸäº›æˆå‘˜çš„åˆå§‹åŒ–ä¸å†<code>getters</code>ã€<code>setters</code> and<code>init method</code>ä¸­ã€‚</p>
</blockquote>

<pre class="highlight"><code class=" hljs objectivec">    <span class="hljs-class"><span class="hljs-keyword">@interface</span> <span class="hljs-title">Foo</span> : <span class="hljs-title">NSObject</span> {</span>
        <span class="hljs-keyword">int</span> _bar;
    }
    <span class="hljs-keyword">@property</span> (<span class="hljs-keyword">assign</span>, <span class="hljs-keyword">nonatomic</span>) <span class="hljs-keyword">int</span> bar;
    <span class="hljs-keyword">@end</span>
    <span class="hljs-class"><span class="hljs-keyword">@implementation</span> <span class="hljs-title">Foo</span></span>
    <span class="hljs-keyword">@synthesize</span> bar = _bar;
    - (<span class="hljs-keyword">void</span>)doSomething {
        _bar = <span class="hljs-number">3</span>; <span class="hljs-comment">// access _bar outside its getter, setter or init</span>
    }
    <span class="hljs-keyword">@end</span></code></pre>

<blockquote>
  <p><font color="red">PSï¼š</font>ç®€å•å’Œå°ä¼™ä¼´è®¨è®ºäº†ä¸‹ï¼Œæ„Ÿè§‰iOSå¼€å‘å¹¶ä¸æ˜¯å¾ˆé€‚åˆã€‚</p>
</blockquote>

<h4 id="10parameter-reassignment-since06-å®šä¹‰ç±»ä¼ é€é—¨ç‚¹å‡»">10ã€parameter reassignment             &nbsp; &nbsp; &nbsp;  <code>Since:0.6</code> <a href="https://github.com/oclint/oclint/blob/master/oclint-rules/rules/convention/ParameterReassignmentRule.cpp" rel="nofollow" target="_blank">å®šä¹‰ç±»ä¼ é€é—¨ï½ç‚¹å‡»</a></h4>

<blockquote>
  <p>Reassigning values to parameters is very problematic in most cases.</p>
  
  <p>ç®€å•è§£é‡Šï¼šå¯¹å‚æ•°è¿›è¡Œé‡æ–°èµ‹å€¼ï¼Œåœ¨å¾ˆå¤šæƒ…å†µä¸‹æ˜¯æœ‰é—®é¢˜çš„ã€‚</p>
</blockquote>

<pre class="highlight"><code class=" hljs livecodeserver">    void example(int <span class="hljs-operator">a</span>) {
        <span class="hljs-keyword">if</span> (<span class="hljs-operator">a</span> &lt; <span class="hljs-number">0</span>) {
            <span class="hljs-operator">a</span> = <span class="hljs-number">0</span>;<span class="hljs-comment"> // reassign parameter a to 0</span>
        }
    }</code></pre>

<blockquote>
  <p><font color="red">PSï¼š</font>ç®€å•æµ‹è¯•äº†ä¼ å€¼æ—¶ä½¿ç”¨æŒ‡é’ˆï¼Œç»æµ‹è¯•ä¸ä¼šæœ‰è­¦å‘Šã€‚ä¹Ÿå°±æ˜¯è¯´ä¸ä¼šå¯¹æŒ‡é’ˆç±»å‹çš„å‚æ•°åšæ£€æŸ¥ã€‚</p>
</blockquote>

<h4 id="11prefer-early-exits-and-continue-since08-å®šä¹‰ç±»ä¼ é€é—¨ç‚¹å‡»">11ã€prefer early exits and continue       &nbsp; &nbsp; &nbsp;  <code>Since:0.8</code> <a href="https://github.com/oclint/oclint/blob/master/oclint-rules/rules/convention/PreferEarlyExitRule.cpp" rel="nofollow" target="_blank">å®šä¹‰ç±»ä¼ é€é—¨ï½ç‚¹å‡»</a></h4>

<blockquote>
  <p>Early exits can reduce the indentation of a block of code, so that reader do not have to remember all the previous decisions, therefore, makes it easier to understand the code.</p>
  
  <p>ç®€å•è§£é‡Šï¼šåœ¨æœ‰é€€å‡ºè¯­å¥ çš„æ—¶å€™ï¼Œåº”è¯¥è®©é€€å‡ºè¯­å¥é å‰ï¼Œè¿™æ ·é˜…è¯»ä»£ç ä½¿ä»£ç å¯ä»¥å¾ˆå¥½çš„è¢«ç†è§£ã€‚</p>
</blockquote>

<pre class="highlight"><code class=" hljs r">    int *doSomething(int a) {
      <span class="hljs-keyword">if</span> (!foo(a) &amp;&amp; bar(a) &amp;&amp; doOtherThing(a)) {
        // <span class="hljs-keyword">...</span> some really long code ....
      }
      <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
    }
    // is preferred as
    int *doSomething(int a) {
      <span class="hljs-keyword">if</span> (foo(a)) {
        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
      }
      <span class="hljs-keyword">if</span> (!bar(a)) {
        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
      }
      <span class="hljs-keyword">if</span> (!doOtherThing(a)) {
        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
      }
      // <span class="hljs-keyword">...</span> some long code ....
    }</code></pre>

<h4 id="12-missing-default-in-switch-statements-since06-å®šä¹‰ç±»ä¼ é€é—¨ç‚¹å‡»">12ã€ missing default in switch statements           &nbsp; &nbsp; &nbsp;  <code>Since:0.6</code> <a href="https://github.com/oclint/oclint/blob/master/oclint-rules/rules/convention/SwitchStatementsShouldHaveDefaultRule.cpp" rel="nofollow" target="_blank">å®šä¹‰ç±»ä¼ é€é—¨ï½ç‚¹å‡»</a></h4>

<blockquote>
  <p>Switch statements should have a default statement.</p>
  
  <p>ç®€å•è§£é‡Šï¼šæ£€æŸ¥ <code>Switch</code>ä¸­<code>default</code>ç¼ºå¤±çš„æƒ…å†µã€‚</p>
</blockquote>

<pre class="highlight"><code class=" hljs cs">    <span class="hljs-keyword">void</span> example(<span class="hljs-keyword">int</span> a) {
        <span class="hljs-keyword">switch</span> (a) {
            <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:
                <span class="hljs-keyword">break</span>;
            <span class="hljs-keyword">case</span> <span class="hljs-number">2</span>:
                <span class="hljs-keyword">break</span>;
            <span class="hljs-comment">// should have a default</span>
        }
    }</code></pre>

<h4 id="13-too-few-branches-in-switch-statement-since06-å®šä¹‰ç±»ä¼ é€é—¨ç‚¹å‡»">13ã€ too few branches in switch statement             &nbsp; &nbsp; &nbsp;  <code>Since:0.6</code> <a href="https://github.com/oclint/oclint/blob/master/oclint-rules/rules/convention/TooFewBranchesInSwitchStatementRule.cpp" rel="nofollow" target="_blank">å®šä¹‰ç±»ä¼ é€é—¨ï½ç‚¹å‡»</a></h4>

<blockquote>
  <p>To increase code readability, when a switch consists of only a few branches, itâ€™s much better to use an if statement instead.</p>
  
  <p>ç®€å•è§£é‡Šï¼šå¦‚æœ<code>switch</code>è¯­å¥æ¡ä»¶å¾ˆå°‘ï¼Œå¯ä»¥ä¸€ç”¨<code>if else</code> ä»£æ›¿ã€‚</p>
</blockquote>

<pre class="highlight"><code class=" hljs cs">    <span class="hljs-keyword">void</span> example(<span class="hljs-keyword">int</span> a) {
        <span class="hljs-keyword">switch</span> (a) {
            <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:
                <span class="hljs-keyword">break</span>;
            <span class="hljs-keyword">default</span>:
                <span class="hljs-keyword">break</span>;
        } <span class="hljs-comment">// Better to use an if statement and check if variable a equals 1.</span>
    }</code></pre>

<blockquote>
  <p>Thresholds: <br />
  MINIMUM_CASES_IN_SWITCH The reporting threshold for count of case statements in a switch statement, de- <br />
  fault value is 3.</p>
</blockquote>

<h1 id="oclintè§„åˆ™-cocoa-éƒ¨åˆ†">OCLintè§„åˆ™ CoCoa éƒ¨åˆ†</h1>

<h4 id="1missing-hash-method">1ã€missing hash method</h4>

<p>&nbsp; &nbsp; &nbsp;  <code>Since:0.8</code> <a href="https://github.com/oclint/oclint/blob/master/oclint-rules/rules/cocoa/ObjCVerifyIsEqualHashRule.cpp" rel="nofollow" target="_blank">å®šä¹‰ç±»ä¼ é€é—¨ï½ç‚¹å‡»</a></p>

<blockquote>
  <p>When isEqual method is overridden, hash method must be overridden, too.</p>
  
  <p>ç®€å•è§£é‡Šï¼š<code>isEqual</code> æ–¹æ³•è¢«é‡å†™, <code>hash</code> æ–¹æ³•ä¹Ÿåº”è¯¥è¢«é‡å†™.</p>
</blockquote>

<pre class="highlight"><code class=" hljs objectivec">    <span class="hljs-class"><span class="hljs-keyword">@implementation</span> <span class="hljs-title">BaseObject</span></span>
    - (<span class="hljs-built_in">BOOL</span>)isEqual:(<span class="hljs-keyword">id</span>)obj {
        <span class="hljs-keyword">return</span> <span class="hljs-literal">YES</span>;
    }
    <span class="hljs-comment">/*
    - (int)hash is missing; If you override isEqual you must override hash too.
    */</span>
    <span class="hljs-keyword">@end</span></code></pre>

<h4 id="2missing-call-to-base-method">2ã€missing call to base method</h4>

<p>&nbsp; &nbsp; &nbsp;  <code>Since:0.8</code> <a href="https://github.com/oclint/oclint/blob/master/oclint-rules/rules/cocoa/ObjCVerifyMustCallSuperRule.cpp" rel="nofollow" target="_blank">å®šä¹‰ç±»ä¼ é€é—¨ï½ç‚¹å‡»</a></p>

<blockquote>
  <p>When a method is declared with <strong>attribute</strong>((annotate(â€œoclint:enforce[base method]â€))) annotation, all of its implementations (including its own and its sub classes) must call the method implementation in super class.</p>
  
  <p>ç®€å•è§£é‡Šï¼šå½“ä½¿ç”¨ <code>__attribute__((annotate("oclint:enforce[must call super]")))</code> æ³¨è§£æ—¶, ä»–çš„æ‰€æœ‰å®ç°ï¼ˆåŒ…æ‹¬ä»–è‡ªå·±å’Œå­ç±»ï¼‰éƒ½å¿…é¡»è°ƒç”¨è¶…ç±»çš„å®ç°</p>
</blockquote>

<pre class="highlight"><code class=" hljs objectivec">    <span class="hljs-class"><span class="hljs-keyword">@interface</span> <span class="hljs-title">UIView</span> (<span class="hljs-title">OCLintStaticChecks</span>)</span>
    - (<span class="hljs-keyword">void</span>)layoutSubviews __attribute__((annotate(<span class="hljs-string">"oclint:enforce[must call super]"</span>)));
    <span class="hljs-keyword">@end</span>
    <span class="hljs-class"><span class="hljs-keyword">@interface</span> <span class="hljs-title">CustomView</span> : <span class="hljs-title">UIView</span></span>
    <span class="hljs-keyword">@end</span>
    <span class="hljs-class"><span class="hljs-keyword">@implementation</span> <span class="hljs-title">CustomView</span></span>
    - (<span class="hljs-keyword">void</span>)layoutSubviews {
        <span class="hljs-comment">// [super layoutSubviews]; is enforced here</span>
    }
    <span class="hljs-keyword">@end</span></code></pre>

<h4 id="3calling-prohibited-method">3ã€calling prohibited method</h4>

<p>&nbsp; &nbsp; &nbsp;  <code>Since:0.10.1</code> <a href="https://github.com/oclint/oclint/blob/master/oclint-rules/rules/cocoa/ObjCVerifyProhibitedCallRule.cpp" rel="nofollow" target="_blank">å®šä¹‰ç±»ä¼ é€é—¨ï½ç‚¹å‡»</a></p>

<blockquote>
  <p>hen a method is declared with <strong>attribute</strong>((annotate(â€œoclint:enforce[prohibited method]â€))) annotation, all of its usages will be prohibited.</p>
  
  <p>ç®€å•è§£é‡Šï¼šå½“ä¸€ä¸ªæ–¹æ³•æ ‡è®°<code>__attribute__((annotate("oclint:enforce[prohibited call]")))</code>æ³¨è§£,æ‰€æœ‰çš„å¼•ç”¨éƒ½å°†è¢«ç¦æ­¢ã€‚</p>
</blockquote>

<pre class="highlight"><code class=" hljs objectivec">    <span class="hljs-class"><span class="hljs-keyword">@interface</span> <span class="hljs-title">A</span> : <span class="hljs-title">NSObject</span></span>
    - (<span class="hljs-keyword">void</span>)foo __attribute__((annotate(<span class="hljs-string">"oclint:enforce[prohibited call]"</span>)));
    <span class="hljs-keyword">@end</span>
    <span class="hljs-class"><span class="hljs-keyword">@implementation</span> <span class="hljs-title">A</span></span>
    - (<span class="hljs-keyword">void</span>)foo {
    }
    - (<span class="hljs-keyword">void</span>)bar {
        [<span class="hljs-keyword">self</span> foo]; <span class="hljs-comment">// calling method `foo` is prohibited.</span>
    }
    <span class="hljs-keyword">@end</span></code></pre>

<h4 id="4calling-protected-method">4ã€calling protected method</h4>

<p>&nbsp; &nbsp; &nbsp;  <code>Since:0.8</code> <a href="https://github.com/oclint/oclint/blob/master/oclint-rules/rules/cocoa/ObjCVerifyProtectedMethodRule.cpp" rel="nofollow" target="_blank">å®šä¹‰ç±»ä¼ é€é—¨ï½ç‚¹å‡»</a></p>

<blockquote>
  <p>Even though there is no <code>protected</code> in Objective-C language level, in a designâ€™s perspective, we sometimes hope to enforce a method only be used inside the class itself or by its subclass. This rule mimics the protected behavior, and alerts developers when a method is called outside its access scope.</p>
  
  <p>ç®€å•è§£é‡Šï¼šåœ¨<code>Objective-C</code> ä¸­è™½ç„¶æ²¡æœ‰<code>protected</code>è¿™ä¸ªæ¦‚å¿µã€‚ä½†æ˜¯åœ¨è®¾è®¡çš„è§’åº¦ï¼Œæˆ‘ä»¬æœ‰æ—¶å¸Œæœ›ä¸€ä¸ªæ–¹æ³•åªå¸Œæœ›è¢«å®ƒè‡ªå·±æˆ–è€…å®ƒçš„å­ç±»è°ƒç”¨ã€‚è¿™ä¸ªæ–¹æ³•å¯ä»¥æ¨¡ä»¿<code>protected</code>åœ¨æœ‰äººè°ƒç”¨çš„æ—¶å€™ç»™ä¸€ä¸ªè­¦å‘Šã€‚</p>
</blockquote>

<pre class="highlight"><code class=" hljs objectivec">    <span class="hljs-class"><span class="hljs-keyword">@interface</span> <span class="hljs-title">A</span> : <span class="hljs-title">NSObject</span></span>
    - (<span class="hljs-keyword">void</span>)foo __attribute__((annotate(<span class="hljs-string">"oclint:enforce[protected method]"</span>)));
    <span class="hljs-keyword">@end</span>
    <span class="hljs-class"><span class="hljs-keyword">@interface</span> <span class="hljs-title">B</span> : <span class="hljs-title">NSObject</span></span>
    <span class="hljs-keyword">@property</span> (<span class="hljs-keyword">strong</span>, <span class="hljs-keyword">nonatomic</span>) A* a;
    <span class="hljs-keyword">@end</span>
     <span class="hljs-comment">//</span>
    <span class="hljs-class"><span class="hljs-keyword">@implementation</span> <span class="hljs-title">B</span></span>
    - (<span class="hljs-keyword">void</span>)bar {
        [<span class="hljs-keyword">self</span><span class="hljs-variable">.a</span> foo]; <span class="hljs-comment">// calling protected method foo from outside A and its subclasses</span>
    }
    <span class="hljs-keyword">@end</span></code></pre>

<h4 id="5missing-abstract-method-implementation">5ã€missing abstract method implementation</h4>

<p>&nbsp; &nbsp; &nbsp;  <code>Since:0.8</code> <a href="https://github.com/oclint/oclint/blob/master/oclint-rules/rules/cocoa/ObjCVerifySubclassMustImplementRule.cpp" rel="nofollow" target="_blank">å®šä¹‰ç±»ä¼ é€é—¨ï½ç‚¹å‡»</a></p>

<blockquote>
  <p>Due to the Objective-C language tries to postpone the decision makings to the runtime as much as possible, an abstract method is okay to be declared but without implementations. This rule tries to verify the subclass implement the correct abstract method.</p>
  
  <p>ç®€å•è§£é‡Šï¼šç”±äº<code>Objective</code>çš„<code>runtime</code>ç‰¹æ€§ï¼ŒæŠ½è±¡æ–¹æ³•å¯ä»¥è¢«å£°æ˜ï¼Œå¯ä»¥ä¸å®ç°ï¼Œè¯¥è§„åˆ™éªŒè¯å­ç±»æ˜¯å¦æ­£ç¡®å®ç°æŠ½è±¡æ–¹æ³•ã€‚</p>
</blockquote>

<pre class="highlight"><code class=" hljs objectivec">    <span class="hljs-class"><span class="hljs-keyword">@interface</span> <span class="hljs-title">Parent</span></span>
    <span class="hljs-comment">//</span>
    - (<span class="hljs-keyword">void</span>)anAbstractMethod __attribute__((annotate(<span class="hljs-string">"oclint:enforce[subclass must implement]"</span>)));
    <span class="hljs-comment">//</span>
    <span class="hljs-keyword">@end</span>
    <span class="hljs-class"><span class="hljs-keyword">@interface</span> <span class="hljs-title">Child</span> : <span class="hljs-title">Parent</span></span>
    <span class="hljs-keyword">@end</span>
    <span class="hljs-comment">//</span>
    <span class="hljs-class"><span class="hljs-keyword">@implementation</span> <span class="hljs-title">Child</span></span>
    <span class="hljs-comment">/*
    // Child, as a subclass of Parent, must implement anAbstractMethod
    - (void)anAbstractMethod {}
    */</span>
    <span class="hljs-keyword">@end</span></code></pre>

<p>å‚è€ƒèµ„æ–™ï¼šhttps://blog.csdn.net/foolsong/article/details/76474125<br />
<strong>å°†ä¸Šæ–‡ä¸­æ‰€æœ‰è§„åˆ™æ±‡èšåœ¨ä¸€ä¸ªé¡µé¢ä¸­ï¼Œæ–¹ä¾¿æœç´¢ã€‚</strong></p>

:ET